


# Imports
# --------
#from scipy import signal
#import matplotlib.pyplot as plt
#from matplotlib.figure import Figure
#from matplotlib.animation import FuncAnimation
#from matplotlib.backends.backend_tkagg import (FigureCanvasTkAgg, NavigationToolbar2Tk)
#from PIL import Image, ImageTk
from math import floor
import promptlib
import serial
#import serial.tools.list_ports
import time
import os
import csv
from datetime import datetime
from tkinter import _setit
from tkinter import *



# Declare global variables
global b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, csv_var
global windowNum, array_size, v_read
global save_file_name_str, save_directory_str
global unit

windowNum = 0
save_file_name_str = ''
save_directory_str = 'csv_files'
array_size = 8
unit = 'uA'
v_read = [] 

'''
--------------------------------------
Max and min ranges for each parameter
--------------------------------------
'''
# Set/Reset/Form Voltages
max_voltage = 5
min_voltage = -5
v_form = 3.3

# Pulse/Blank Time
max_time = 125
min_time = 0

# No. of Cycles
max_cycles = 100000


'''
-------
Serial
-------
Functions which deal with serial communication between the GUI and microcontroller PCB
'''
# Sends list of parameters as bytes to PCB and returns output list
def serialExecution(input):
    
    # output arrays read from serial port
    output = []
    
    # Find serial COM Port
    port = findPort()
   
    # Baudrate
    rate = 115200

    ser = serial.Serial(port, rate, timeout=0, bytesize=serial.EIGHTBITS) # Define serial device 

    ser.write(bytearray(input)) # Send list of integer values to board as byte array

    time.sleep(0.001)
    
    # While loop to continuously read data
    while 1:
        
        # read value(s) from board and convert to strings
        data = ser.readline().decode("ascii") 
        print()
        
        time.sleep(0.001)
        
        # remove unwanted characters
        data = data.replace('\n', '')
        data = data.replace('\r', '')
        data = data.replace('k', '')
        data = data.replace('A', '')
        data = data.replace('u', '')
        
        # Possible data read
        if data == 'Received Frame Eror': # If error with input list tell user to hit reset switch 
            return 'reset switch'
            #print("Hit reset switch to resubmit data")
            
        elif data == 'Waiting for command': # when data is finished reading or reset switch is pressed -> end loop and wait for user to re-submit input array
            break
        
        elif data == 'Value is OutOfRange': # (only for script testing) continues reading if bad value
            continue
        
        elif data != '': # if data read is not empty add to list of output reads
                
            #print(data)
            output.append(float(data))

                    
            
    return output

# Finds the port the PCB is plugged into
def findPort():
    
    ports = serial.tools.list_ports.comports()
    #print(ports)
    
    comPort = None
    
    for i in ports:
        strPort = str(i)
        if 'Silicon Labs CP210x' in strPort:
            splitPort = strPort.split(' ')
            comPort = splitPort[0]
        
    return comPort


'''
-----------------
Direct Exporting
-----------------
Functions which deal with creating the CSV file to export to
'''
# Takes the list of values read from the PCB board and puts them into a csv file within the project folder called 'csv_files'
def export_csv(data, export_file_name, directory):
    
    if export_file_name == '':
        
        now = datetime.now()
        dt_string = now.strftime("%d-%m-%Y %Hh_%Mm_%Ss")
        export_file_name = dt_string
        dir = directory + '\\' + export_file_name + '.csv'
        
    else:
        
        export_num = get_file_num(export_file_name, directory)
        dir = directory + '\\' + export_file_name + export_num + '.csv'
        
    
    with open(dir, 'w', newline='') as csvfile:
        
        # create write variable
        write = csv.writer(csvfile)
        
        for i in data:
            write.writerow(i)

# Returns the index of file name exported if user tries to export a file with the same name (filename1, filename2, ... filenameX)
def get_file_num(export_file, directory):
    
    numList = [0]
    
    for file in os.listdir(directory):
        if export_file in file:
            file = file.replace(export_file, '')
            file = file.replace('.csv', '')
            numList.append(int(file))
    
    return str(max(numList) + 1)



'''
----------------
Check and Order 
----------------
functions which take the list of values generated by the user in the GUI
and goes through each value making sure they are in proper range. 

If values are not in range it adds a warning to then print into the output box of the GUI.
If values are in range it arranges the values in a list into the correct sequence for the
PCB to generate appropriate pulses.
'''
# Single Device/Endurance Operation
def SD_check_and_order(byte2, byte3, byte4, byte5, byte6, byte7, byte8, byte9, byte10, byte11, byte12, byte13, byte14, byte15, byte16, byte17, byte18, byte19, byte20):
    
    err_list = ['error']
    serial_array = [] # ordered array to return
    serial_array.append(128) # initial byte
    
    # Pulse 1 parameter check
    # -----------------------

    if byte2 == 1: # If forming
        
        serial_array.append(int(byte2))
        
        # time parameter (byte3)
        if (byte3 < min_time or byte3 > max_time):
            err_list.append(3)
        else:
            serial_array.append(int(byte3))
            
        # voltage parameter (byte4)
        if (byte4 != v_form):
            err_list.append(4)
        else:
            serial_array.append(voltageToHex(byte4))

        # period parameter (byte5)
        if (byte5 < min_time or byte5 > max_time):
            err_list.append(5)
        else:
            serial_array.append(int(byte5))

        
    elif byte2 == 2: # if Set
        
        serial_array.append(int(byte2))
        
        # time parameter
        if (byte3 < min_time or byte3 > max_time):
            err_list.append(3)
        else:
            serial_array.append(int(byte3))
            
        # Set voltage parameter
        if (byte4 < 0 or byte4 > max_voltage):
            err_list.append(4)
        else:
            serial_array.append(voltageToHex(byte4))

        # period parameter
        if (byte5 < min_time or byte5 > max_time):
            err_list.append(5)
        else:
            serial_array.append(int(byte5))
        
        
    elif byte2 == 3: # if Reset
        
        serial_array.append(int(byte2))

        # time parameter
        if (byte3 < min_time or byte3 > max_time):
            err_list.append(3)
        else:
            serial_array.append(int(byte3))
            
        # voltage parameters
        if (byte4 > 0 or byte4 < min_voltage):
            err_list.append(4)
        else:
            serial_array.append(voltageToHex(byte4))

        # period parameters
        if (byte5 < min_time or byte5 > max_time):
            err_list.append(5)
        else:
            serial_array.append(int(byte5))
            
    else: # if None

        # Make it a set pulse at zero voltage
        serial_array.append(int(2)) # set
        serial_array.append(int(1))
        serial_array.append(int(0)) # 0 volts
        serial_array.append(int(1)) 
            
    
    # Pulse 2 
    # ----------
    if byte6 == 4: # if Read
        
        serial_array.append(int(byte6))

        # time parameter
        if byte7 < min_time or byte7 > max_time:
            err_list.append(7)
        else:
            serial_array.append(int(byte7))
            
        # voltage parameter
        if byte8 > max_voltage or byte8 < min_voltage:
            err_list.append(8)
        else:
            serial_array.append(voltageToHex(byte8))

        # period parameter
        if byte9 < min_time or byte9 > max_time:
            err_list.append(9)
        else:
            serial_array.append(int(byte9))


    else: # if Stop
        
        serial_array.append(int(byte6))
        serial_array.append(0) # time
        serial_array.append(0) # voltage
        serial_array.append(0) # blank
     
    
    # Pulse 3
    # ---------
    
    if byte10 == 2: # if Set
        
        serial_array.append(int(byte10))

        # time parameter
        if byte11 < min_time or byte11 > max_time:
            err_list.append(11)
        else:
            serial_array.append(int(byte11))
            
        # voltage parameter
        if byte12 < 0 or byte12 > max_voltage:
            err_list.append(12)
        else:
            serial_array.append(voltageToHex(byte12))

        # period parameter
        if byte13 < min_time or byte13 > max_time:
            err_list.append(13)
        else:
            serial_array.append(int(byte13))


    elif byte10 == 3: # if Reset
        
        serial_array.append(int(byte10))

        # time parameter
        if byte11 < min_time or byte11 > max_time:
            err_list.append(11)
        else:
            serial_array.append(int(byte11))
            
        # voltage parameter
        if byte12 > max_voltage or byte12 < min_voltage:
            err_list.append(12)
        else:
            serial_array.append(voltageToHex(byte12))

        # period parameter
        if byte13 < min_time or byte13 > max_time:
            err_list.append(13)
        else:
            serial_array.append(int(byte13))
            
    else: # if None

        # Make it a set pulse at zero voltage
        serial_array.append(int(2)) # set
        serial_array.append(int(100))
        serial_array.append(int(0)) # 0 volts
        serial_array.append(int(100)) 
            
    
    # Pulse 4
    # ---------
    
    if byte14 == 4: # if Read
        
        serial_array.append(int(byte14))

        # time parameter
        if byte15 < min_time or byte15 > max_time:
            err_list.append(15)
        else:
            serial_array.append(int(byte15))
            
        # voltage parameter
        if byte16 > max_voltage or byte16 < min_voltage:
            err_list.append(16)
        else:
            serial_array.append(voltageToHex(byte16))

        # period parameter
        if byte17 < min_time or byte17 > max_time:
            err_list.append(17)
        else:
            serial_array.append(int(byte17))
    
    else: # if Stop
        
        serial_array.append(int(byte14))
        serial_array.append(int(0))
        serial_array.append(int(0))
        serial_array.append(int(0))

    
    # Cycles, Row, Column
    # ---------------------
    if byte18 < 1 or byte18 > max_cycles: # num of cycles
        err_list.append(18)
    else:
        serial_array.append(int(byte18))

    serial_array.append(int(byte19))
    serial_array.append(int(byte20))
    serial_array.append(129)
    
    
    
    # If error list has any errors return error list, ir not return ordered bytes
    if len(err_list) > 1:
        return err_list
    else:
        return serial_array
       
# Column Programming Operation
def col_check_and_order(byte2, byte3, byte4, byte5, byte6, byte7, byte8, byte9, byte10, byte11, byte12, byte13, byte14, byte15, byte16, byte17, byte18, byte19, byte20):
    
    err_list = ['error']
    serial_array = [] # ordered array to return
    serial_array.append(128) # initial byte
    
    # Binary pusle setup
    # --------------------
    # Set/reset time
    if byte2 < min_time or byte2 > max_time:
        err_list.append(2)
    else:
        serial_array.append(int(byte2))
    # Set Voltage
    if byte3 < 0 or byte3 > max_voltage:
        err_list.append(3)
    else:
        serial_array.append(voltageToHex(byte3))
    # Reset voltage
    if byte4 > 0 or byte4 < min_voltage:
        err_list.append(4)
    else:
        serial_array.append(voltageToHex(byte4))
    # Blank time  
    if byte5 < min_time or byte5 > max_time:
        err_list.append(5)
    else:
        serial_array.append(int(byte5))
    
    
    # Read pulse setup
    # ----------------
    # read time
    if byte6 < min_time or byte6 > max_time:
        err_list.append(6)
    else:
        serial_array.append(int(byte6))
    # read voltage
    if byte7 > max_voltage or byte7 < min_voltage:
        err_list.append(7)
    else:
        serial_array.append(voltageToHex(byte7))
    # read blank
    if byte8 < min_time or byte8 > max_time:
        err_list.append(8)
    else:
        serial_array.append(int(byte8))
    
    
    # Device states
    # --------------
    serial_array.append(int(byte9))
    serial_array.append(int(byte10))
    serial_array.append(int(byte11))
    serial_array.append(int(byte12))
    serial_array.append(int(byte13))
    serial_array.append(int(byte14))
    serial_array.append(int(byte15))
    serial_array.append(int(byte16))
    
    # Rest of bytes
    serial_array.append(int(byte17))
    serial_array.append(int(1)) # can only do 1 cycle of column programming
    serial_array.append(int(byte19))
    serial_array.append(int(byte20))
    serial_array.append(int(129))
        
    
    # If error list has any errors return error list, ir not return ordered bytes
    if len(err_list) > 1:
        return err_list
    else:
        return serial_array

# VMM Operation Operation
def vmm_check_and_order(byte2, byte3, byte4, byte5, byte6, byte7, byte8, byte9, byte10, byte11, byte12, byte13, byte14, byte15, byte16, byte17, byte18, byte19, byte20):


    err_list = ['error']
    serial_array = [] # ordered array to return
    serial_array.append(128) # initial byte

    serial_array.append(int(byte2))
    serial_array.append(int(byte3))
    serial_array.append(int(byte4))
    serial_array.append(int(byte5))
    
    if byte6 < min_time or byte6 > max_time:
        err_list.append(6)
    else:
        serial_array.append(int(byte6))

    if byte7 < min_voltage or byte7 > max_voltage:
        err_list.append(7)
    else:
        serial_array.append(voltageToHex(abs(byte7)))

    serial_array.append(int(byte8))
    
    serial_array.append(int(byte9))
    serial_array.append(int(byte10))
    serial_array.append(int(byte11))
    serial_array.append(int(byte12))
    serial_array.append(int(byte13))
    serial_array.append(int(byte14))
    serial_array.append(int(byte15))
    serial_array.append(int(byte16))
    
    serial_array.append(int(byte17))

    if byte18 < 1 or byte18 > max_cycles:
        err_list.append(18)
    else:
        serial_array.append(int(byte18))

    serial_array.append(int(byte19))
    serial_array.append(int(byte20))
    serial_array.append(129)
    

    # If error list has any errors return error list, ir not return ordered bytes
    if len(err_list) > 1:
        return err_list
    else:
        return serial_array

# Converts decimals to whole numbers
def voltageToHex(voltageDec):
    multiplier = 10
    voltageDec *= multiplier
    if voltageDec >= 0:
        return int(voltageDec)
    else:
        return 256 + int(voltageDec)



'''
------------------------
Single Device/Endurance
------------------------
Functions which are involved with performing Single Device and Endurance operation windows
'''
# Initializes opening the single device window
def open_SingleDevice():
    
    global singleDevice_gui, columnBinary_gui, windowNum, endurance_checkbox
    
    # Change states of buttons in master window
    SD_button["state"] = DISABLED
    col_button["state"] = NORMAL
    vmm_button["state"] = NORMAL
    endurance_button["state"] = NORMAL
    
    
    SD_button["relief"] = SUNKEN
    col_button["relief"] = RAISED
    vmm_button["relief"] = RAISED
    endurance_button["relief"] = RAISED
    
    # Close other operation windows and open single device
    if windowNum == 1:
        print("window already open")
    elif windowNum == 2:
        columnBinary_gui.destroy()
        singleDevice_window(False)
    elif windowNum == 3:
        columnBinary_gui.destroy()
        singleDevice_window(False)
    elif windowNum == 4:
        endurance_checkbox.deselect()
        toggle_endurance()
    else:
        singleDevice_window(False)

# Initializes opening the endurance window
def open_endurance():
    
    global singleDevice_gui, columnBinary_gui, windowNum, endurance_checkbox
    
    # Change states of buttons in master window
    SD_button["state"] = NORMAL
    col_button["state"] = NORMAL
    vmm_button["state"] = NORMAL
    endurance_button["state"] = DISABLED
    
    SD_button["relief"] = RAISED
    col_button["relief"] = RAISED
    vmm_button["relief"] = RAISED
    endurance_button["relief"] = SUNKEN
    
    # Close other operation windows and open single device
    if windowNum == 1:
        endurance_checkbox.select()
        toggle_endurance()
    elif windowNum == 2:
        columnBinary_gui.destroy()
        singleDevice_window(True)
    elif windowNum == 3:
        columnBinary_gui.destroy(False)
        singleDevice_window(True)
    elif windowNum == 4:
        print("window already open")
    else:
        singleDevice_window(True)

# Creates the operation window depending on which the user opened
def singleDevice_window(endurance):
    
    global b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, csv_var, endurance_var
    global frame1, frame2, frame3, frame4, frame5, label1_3
    global singleDevice_gui, windowNum, v_read
    global unit_button, unit
    
    windowNum = 1
    v_read = []
    
    singleDevice_gui = Toplevel(master)
    
    singleDevice_gui.title("Single Device Operation")
    SD_canvas = Canvas(singleDevice_gui, width=700, height=600)
    SD_canvas.grid(rowspan=20,columnspan=4) # separates window into N number of equally spaced columns/rows
    
    singleDevice_gui.resizable(False,False)
    singleDevice_gui.protocol("WM_DELETE_WINDOW", on_closing) 

    # Add SUNY Poly Logo
    # logo = Image.open('C:\Users\jpelt\Desktop\exe\poly_logo.png')
    # logo = logo.resize((300,50), Image.Resampling.LANCZOS)
    # logo = ImageTk.PhotoImage(logo)
    # logo_label = Label(singleDevice_gui, image=logo)
    # logo_label.image = logo
    # logo_label.place(relx=0.5, rely=0.05)


    # Declare input variables (bytes 2-20)
    b2 = StringVar()
    b3 = StringVar()
    b4 = StringVar()
    b5 = StringVar()
    b6 = StringVar()
    b7 = StringVar()
    b8 = StringVar()
    b9 = StringVar()
    b10 = StringVar()
    b11 = StringVar()
    b12 = StringVar()
    b13 = StringVar()
    b14 = StringVar()
    b15 = StringVar()
    b16 = StringVar()
    b17 = StringVar()
    b18 = StringVar()
    b19 = StringVar()
    b20 = StringVar()

    csv_var = IntVar()
    endurance_var = IntVar()

    # Default values for each byte
    b2.set("Set")
    b3.set("100")
    b4.set("2.5")
    b5.set("100")

    b6.set("Read")
    b7.set("100")
    b8.set("-0.2")
    b9.set("100")

    b10.set("Reset")
    b11.set("100")
    b12.set("-1.5")
    b13.set("100")

    b14.set("Read")
    b15.set("100")
    b16.set("-0.2")
    b17.set("100")

    b18.set("1")
    b19.set("1")
    b20.set("1")

    # Title Labels
    titleLabel = Label(singleDevice_gui, text="ReRam Testing", font = ('calibre',20, 'bold'))
    titleLabel.place(relx=0.1, rely=0.05)

    global subLabel
    subLabel = Label(singleDevice_gui, text="Single Device", font = ('calibre',14,'normal'))
    subLabel.place(relx=0.15, rely=0.12)

    # Pulse 1
    # ------------
    # Frame
    frame1 = LabelFrame(singleDevice_gui, text="Pulse 1 (Form/Set/Reset)", padx=10, pady=10)
    frame1.place(relx=0.1, rely=0.2)

    # Labels for inputs
    global label1_3
    label1_1 = Label(frame1, text="Pulse Type:").grid(row=0, column=0, padx=10)
    label1_2 = Label(frame1, text="Time of Pulse:").grid(row=1, column=0, padx=10)
    label1_3 = Label(frame1, text="us")
    label1_3.grid(row=1, column=2)
    label1_4 = Label(frame1, text="Voltage of Pulse:").grid(row=2, column=0, padx=10)
    label1_5 = Label(frame1, text="V").grid(row=2, column=2)
    label1_6 = Label(frame1, text="Blank Period:").grid(row=3, column=0, padx=10)
    label1_7 = Label(frame1, text="us").grid(row=3, column=2)

    # Drop down box (Form, Set, Reset)
    global pulse1Drop
    pulse1Drop = OptionMenu(frame1, b2, "Form", "Set", "Reset", "None", command=update_pulse1)
    pulse1Drop.grid(row=0, column=1)

    # Input fields (time, voltage, blank)
    global pulse1Voltage, pulse1Time, pulse1Blank
    pulse1Time = Entry(frame1, width=5, textvariable=b3, font = ('calibre',10,'normal'), bg="white")
    pulse1Time.grid(row=1, column=1)

    pulse1Voltage = Entry(frame1, width=5, textvariable=b4, font = ('calibre',10,'normal'), bg="white")
    pulse1Voltage.grid(row=2, column=1)

    pulse1Blank= Entry(frame1, width=5, textvariable=b5, font = ('calibre',10,'normal'), bg="white")
    pulse1Blank.grid(row=3, column=1)

    # Pulse 2
    # ------------
    # Frame
    frame2 = LabelFrame(singleDevice_gui, text="Pulse 2 (Read/Stop)", padx=10, pady=10)
    frame2.place(relx=0.5, rely=0.2)

    # Labels for inputs
    label2_1 = Label(frame2, text="Pulse Type:").grid(row=0, column=0, padx=10)
    label2_2 = Label(frame2, text="Time of Pulse:").grid(row=1, column=0, padx=10)
    label2_3 = Label(frame2, text="us").grid(row=1, column=2)
    label2_4 = Label(frame2, text="Voltage of Pulse:").grid(row=2, column=0, padx=10)
    label2_5 = Label(frame2, text="V").grid(row=2, column=2)
    label2_6 = Label(frame2, text="Blank Period:").grid(row=3, column=0, padx=10)
    label2_7 = Label(frame2, text="us").grid(row=3, column=2)

    # Drop down box (Form, Set, Reset)
    pulse2Drop = OptionMenu(frame2, b6, "Read", "Stop", command=update_pulse2)
    pulse2Drop.grid(row=0, column=1)

    # Input fields (time, voltage, blank)
    global pulse2Voltage, pulse2Time, pulse2Blank
    
    pulse2Time = Entry(frame2, width=5, textvariable=b7, font = ('calibre',10,'normal'), bg="white")
    pulse2Time.grid(row=1, column=1)

    pulse2Voltage = Entry(frame2, width=5, textvariable=b8, font = ('calibre',10,'normal'), bg="white")
    pulse2Voltage.grid(row=2, column=1)

    pulse2Blank= Entry(frame2, width=5, textvariable=b9, font = ('calibre',10,'normal'), bg="white")
    pulse2Blank.grid(row=3, column=1)

    # Pulse 3 (Read/Set)
    # ------------
    # Frame
    frame3 = LabelFrame(singleDevice_gui, text="Pulse 3 (Set/Reset)", padx=10, pady=10)
    frame3.place(relx=0.1, rely=0.43)

    # Labels for inputs
    label3_1 = Label(frame3, text="Pulse Type:").grid(row=0, column=0, padx=10)
    label3_2 = Label(frame3, text="Time of Pulse:").grid(row=1, column=0, padx=10)
    label3_3 = Label(frame3, text="us").grid(row=1, column=2)
    label3_4 = Label(frame3, text="Voltage of Pulse:").grid(row=2, column=0, padx=10)
    label3_5 = Label(frame3, text="V").grid(row=2, column=2)
    label3_6 = Label(frame3, text="Blank Period:").grid(row=3, column=0, padx=10)
    label3_7 = Label(frame3, text="us").grid(row=3, column=2)

    # Drop down box (Form, Set, Reset)
    global pulse3Drop
    pulse3Drop = OptionMenu(frame3, b10, "Set", "Reset", "None", command=update_pulse3)
    pulse3Drop.grid(row=0, column=1)

    # Input fields (time, voltage, blank)
    global pulse3Voltage, pulse3Time, pulse3Blank
    
    pulse3Time = Entry(frame3, width=5, textvariable=b11, font = ('calibre',10,'normal'), bg="white")
    pulse3Time.grid(row=1, column=1)

    pulse3Voltage = Entry(frame3, width=5, textvariable=b12, font = ('calibre',10,'normal'), bg="white")
    pulse3Voltage.grid(row=2, column=1)

    pulse3Blank= Entry(frame3, width=5, textvariable=b13, font = ('calibre',10,'normal'), bg="white")
    pulse3Blank.grid(row=3, column=1)

    # Pulse 4 (Read/Stop)
    # ------------
    # Frame
    frame4 = LabelFrame(singleDevice_gui, text="Pulse 4 (Read/Stop)", padx=10, pady=10)
    frame4.place(relx=0.5, rely=0.43)

    # Labels for inputs
    label4_1 = Label(frame4, text="Pulse Type:").grid(row=0, column=0, padx=10)
    label4_2 = Label(frame4, text="Time of Pulse:").grid(row=1, column=0, padx=10)
    label4_3 = Label(frame4, text="us").grid(row=1, column=2)
    label4_4 = Label(frame4, text="Voltage of Pulse:").grid(row=2, column=0, padx=10)
    label4_5 = Label(frame4, text="V").grid(row=2, column=2)
    label4_6 = Label(frame4, text="Blank Period:").grid(row=3, column=0, padx=10)
    label4_7 = Label(frame4, text="us").grid(row=3, column=2)

    # Drop down box (Form, Set, Reset)
    global pulse4Drop
    pulse4Drop = OptionMenu(frame4, b14, "Read", "Stop", command=update_pulse4)
    pulse4Drop.grid(row=0, column=1)

    # Input fields (time, voltage, blank)
    global pulse4Voltage, pulse4Time, pulse4Blank
    
    pulse4Time = Entry(frame4, width=5, textvariable=b15, font = ('calibre',10,'normal'), bg="white")
    pulse4Time.grid(row=1, column=1)

    pulse4Voltage = Entry(frame4, width=5, textvariable=b16, font = ('calibre',10,'normal'), bg="white")
    pulse4Voltage.grid(row=2, column=1)

    pulse4Blank= Entry(frame4, width=5, textvariable=b17, font = ('calibre',10,'normal'), bg="white")
    pulse4Blank.grid(row=3, column=1)


    # Cycles, Column/Row 
    # -------------------
    # Frame
    frame5 = LabelFrame(singleDevice_gui, padx=10, pady=10)
    frame5.place(relx=0.33, rely=0.68)

    # Input field (cycles)
    global numCycles
    numCycles = Entry(frame5, width=5, textvariable=b18, font = ('calibre',10,'normal'), bg="white")
    numCycles.grid(row=0, column=1, padx=2)

    # Drop downs (row/column)
    global rowNum, colNum
    rowNum = OptionMenu(frame5, b20, "1", "2", "3", "4", "5", "6", "7", "8")
    rowNum.grid(row=0, column=3, padx=2)
    colNum = OptionMenu(frame5, b19, "1", "2", "3", "4", "5", "6", "7", "8")
    colNum.grid(row=0, column=5, padx=2)

    # Labels
    label2_1 = Label(frame5, text="Cycles:").grid(row=0, column=0)
    label2_2 = Label(frame5, text="Row:").grid(row=0, column=2)
    label2_3 = Label(frame5, text="Column:").grid(row=0, column=4)
    
    # Exporting Checkbox
    exp_csv = Checkbutton(singleDevice_gui, text="Export to CSV", variable=csv_var)
    exp_csv.place(relx=0.78, rely=0.655)

    # Desired Range
    global min_output_range, max_output_range, rangeLabel4, min_output, max_output, range_checkbox, range_var, n_range, n_range_entry
    min_output = StringVar()
    max_output = StringVar()
    n_range = IntVar()
    n_range.set(1)
    range_var = IntVar()
    rangeLabel1 = Label(singleDevice_gui, text="-").place(relx=0.16, rely=0.728)
    rangeLabel2 = Label(singleDevice_gui, text="Min").place(relx=0.11, rely=0.70)
    rangeLabel3 = Label(singleDevice_gui, text="Max").place(relx=0.19, rely=0.70)
    rangeLabel4 = Label(singleDevice_gui, text="Desired Range (" + unit + ")")
    rangeLabel4.place(relx=0.13, rely=0.663)
    rangeLabel5 = Label(singleDevice_gui, text="N:").place(relx=0.275, rely=0.70)
    min_output_range = Entry(singleDevice_gui, width=5, textvariable=min_output, state=DISABLED, font = ('calibre',10,'normal'), bg="white")
    min_output_range.place(relx=0.1, rely=0.73)
    max_output_range = Entry(singleDevice_gui, width=5, textvariable=max_output, state=DISABLED, font = ('calibre',10,'normal'), bg="white")
    max_output_range.place(relx=0.18, rely=0.73)
    
    n_range_entry = Entry(singleDevice_gui, width=5, textvariable=n_range, state=DISABLED, font = ('calibre',10,'normal'), bg="white")
    n_range_entry.place(relx=0.26, rely=0.73)

    range_checkbox = Checkbutton(singleDevice_gui, text="Choose Output Range", variable=range_var, command=toggle_range)
    range_checkbox.place(relx=0.78, rely=0.698)

    # Endurance Checkbox
    global endurance_checkbox
    endurance_checkbox = Checkbutton(singleDevice_gui, text="Endurance Mode", variable=endurance_var, command=toggle_endurance)
    endurance_checkbox.place(relx=0.78, rely=0.74)
    if endurance == TRUE:
        endurance_checkbox.select()
        toggle_endurance()

    # Output text box
    global outputBox
    outputBox = Label(singleDevice_gui, text="", bd=1, relief=SUNKEN, pady=5, height=6, width=13, bg="light gray")
    outputBox.place(relx=0.1665, rely=0.78, anchor=N)
    
    # Message text box
    global msgBox
    msgBox = Label(singleDevice_gui, text="", bd=1, relief=SUNKEN, height=4, width=44, bg="light gray")
    msgBox.place(relx=0.27, rely=0.84)

    # Pulse Generator
    # global pulseGen_button
    # waveImg = Image.open('wave.png')
    # waveImg = waveImg.resize((35,25), Image.Resampling.LANCZOS)
    # waveImg = ImageTk.PhotoImage(waveImg)
    # pulseGen_button = Button(singleDevice_gui, image=waveImg, command=SD_pulseGen_window)
    # pulseGen_button.image = waveImg
    # pulseGen_button.place(relx=0.85, rely=0.6)

    # Unit button
    unit_label = Label(singleDevice_gui, text="Unit:").place(relx=0.795, rely=0.79)
    unit_button = Button(singleDevice_gui, text=unit, command=toggle_unit, width=5, padx=2, pady=1, bg="light gray")
    unit_button.place(relx=0.85,rely=0.785)
    
    # Clear button
    clear_button = Button(singleDevice_gui, text="Clear", command=SD_clear_output, padx=8, pady=15, bg="white")
    clear_button.place(relx=0.74,rely=0.85)

    # Submit button
    submit_button = Button(singleDevice_gui, text="Send ", command=SD_submit_data, padx=20, pady=15, bg="white")
    submit_button.place(relx=0.85,rely=0.85)

# Submits all parameters to check and order, then send to PCB board for both Single Device and Endurance 
def SD_submit_data():
    
    global v_read, unit
    
    msgBox['text'] = ''
    outputBox['text'] = ''
    
    # Convert pulse 1 inputs into decimal numbers
    byte2 = b2.get()
    if byte2 == "Form":
        byte2 = float(1)
    elif byte2 == "Set":
        byte2 = float(2)
    elif byte2 == "Reset":
        byte2 = float(3)
    
    if byte2 == 1.0: # If forming
        byte3 = float(b3.get())
    else:
        byte3 = float(b3.get())
        
    byte4 = float(b4.get())
    byte5 = float(b5.get())
    
    # Convert pulse 2 inputs into decimal numbers
    byte6 = b6.get()
    if byte6 == "Read": # If read
        byte6 = float(4)
        byte7 = float(b7.get())
        byte8 = float(b8.get())
        byte9 = float(b9.get())
        
    else: # If stop
        byte6 = float(0)
        byte7 = float(0)
        byte8 = float(0)
        byte9 = float(0)
        
    # Convert pulse 3 inputs into decimal numbers
    byte10 = b10.get()
    if byte10 == "Set":
        byte10 = float(2)
    elif byte10 == "Reset":
        byte10 = float(3)
        
    byte11 = float(b11.get())
    byte12 = float(b12.get())
    byte13 = float(b13.get())
    
    # Convert pulse 4 inputs into decimal numbers
    byte14 = b14.get()
    if byte14 == "Read": # If read
        byte14 = float(4)
        byte15 = float(b15.get())
        byte16 = float(b16.get())
        byte17 = float(b17.get())
        
    else: # If stop
        byte14 = float(0)
        byte15 = float(0)
        byte16 = float(0)
        byte17 = float(0)
    
    byte18 = float(b18.get())
    byte19 = float(b19.get())
    byte20 = float(b20.get())
    
    v_read = [byte8, byte16]

    # Order bytes in sequence and send to board/find errors and display on screen
    input_array = SD_check_and_order(byte2, byte3, byte4, byte5, byte6, byte7, byte8, byte9, byte10, byte11, byte12, byte13, byte14, byte15, byte16, byte17, byte18, byte19, byte20)

    # If returns error list display errors to user
    if input_array[0] == "error":
        
        for n in input_array:
            if n == 'error':
                i = n
            else:
                i = int(n)
            # Pulse 1
            if i == 3:
                pulse1Time["bg"] = 'red'
            if i == 4:
                pulse1Voltage["bg"] = 'red'
            if i == 5:
                pulse1Blank["bg"] = 'red'
            # Pulse 2
            if i == 7:
                pulse2Time["bg"] = 'red'
            if i == 8:
                pulse2Voltage["bg"] = 'red'
            if i == 9:
                pulse2Blank["bg"] = 'red'
            # Pulse 3
            if i == 11:
                pulse3Time["bg"] = 'red'
            if i == 12:
                pulse3Voltage["bg"] = 'red'
            if i == 13:
                pulse3Blank["bg"] = 'red'
            # Pulse 4
            if i == 15:
                pulse4Time["bg"] = 'red'
            if i == 16:
                pulse4Voltage["bg"] = 'red'
            if i == 17:
                pulse4Blank["bg"] = 'red'
            if i == 18:
                numCycles["bg"] = 'red'
                
            msgBox["text"] = "Cannot submit pulse wave, all red values are out of range \nPress clear to remove"
            outputBox["text"] = ""
             
    else: # No error in any inputs 
        
        pulse1Time["bg"] = 'white'
        pulse1Voltage["bg"] = 'white'
        pulse1Blank["bg"] = 'white'
        pulse2Time["bg"] = 'white'
        pulse2Voltage["bg"] = 'white'
        pulse2Blank["bg"] = 'white'
        pulse3Time["bg"] = 'white'
        pulse3Voltage["bg"] = 'white'
        pulse3Blank["bg"] = 'white'
        pulse4Time["bg"] = 'white'
        pulse4Voltage["bg"] = 'white'
        pulse4Blank["bg"] = 'white'
        numCycles["bg"] = 'white'
        
        board_output = []
        
        if int(endurance_var.get()) == 1: # Endurance
        
            device_output_list = []
        
            for row in range(array_size): # loop through rows
                for col in range(array_size): # loop through columns
                    
                    # Set row and column values to byte array
                    input_array[18] = int(col + 1)
                    input_array[19] = int(row + 1)
                    
                    try:

                        # Send byte array to board through serial
                        if byte18 <= 125: # If cycles less than 125 run normal serial execution
                            
                            board_output = serialExecution(input_array)
                            
                        else: # If cycles greater than 125 then loop through serial executions of 125 until last loop then do remaining cycles
                            
                            loops = floor(byte18/125) + 1 # Number of loops of 125 cycles
                            remaining = (byte18 % 125) # Remaining cycles at last loop
                            board_output = []
                            
                            for i in range(loops):
                                
                                if i != loops - 1: # If not last loop
                                    
                                    input_array[17] = int(125)
                                    output = serialExecution(input_array)
                                    board_output += output
                                
                                else: # If last loop set cycles to remaining   
                                    
                                    input_array[17] = int(remaining)
                                    output = serialExecution(input_array)
                                    board_output += output
                        
                        # Change units
                        if unit == 'kOhm':
                            if byte14 == 4: # if read
                                convert_unit(board_output, byte8, byte16)
                            else: # if stop
                                convert_unit(board_output, byte8, byte8)

                    except Exception as e:
                        
                        msgBox['text'] = 'Board connection issue\nCheck if board is plugged in or if drivers not installed'
                        outputBox["text"] = ""
                    

                    device_output_list.append(board_output)


        elif int(range_var.get()) == 1: # If choosing output range

            attempt_list = []
            
            try:
                
                n = int(n_range.get())
                max = float(max_output.get())
                min = float(min_output.get())
                
            except:
                
                msgBox['text'] = 'One or more range inputs are non-number values'
                n = 0
                max = 0
                min = 0
            
            if n > 0: # if at least 1 iteration
            
                input_array[17] = int(1) # Allow only 1 cycle
                
                try:
                    
                    for i in range(n): # loop through N iterations set by user
                        
                        output = serialExecution(input_array) # Get board output

                        # Change units
                        if unit == 'kOhm':
                            if byte14 == 4: # if read
                                convert_unit(output, byte8, byte16) 
                            else: # if stop
                                convert_unit(output, byte8, byte8)
                        
                        
                        attempt_list += output
                        val = output[-1] # Get last value read
                        
                        if val >= min and val <= max: # If output value is in range stop looping
                            board_output = [val]
                            iterations = i + 1
                            break
                        
                        if i == n - 1: 
                            msgBox["text"] = "No value in range"  
                            
                except Exception as e:
                    
                    #print('Error: ' + str(e))
                    msgBox['text'] = 'Board connection issue\nCheck if board is plugged in or if drivers not installed'
                    outputBox["text"] = ""
        

        else: # Single Device
            
            try:
                
                # Send byte array to board through serial
                if byte18 <= 125: # If cycles less than 125 run normal serial execution
                    
                    board_output = serialExecution(input_array)
                    
                else: # If cycles greater than 125 then loop through serial executions of 125 until last loop then do remaining cycles
                    
                    loops = floor(byte18/125) + 1 # Number of loops of 125 cycles
                    remaining = (byte18 % 125) # Remaining cycles at last loop
                    board_output = []
                    
                    for i in range(loops):
                        
                        if i != loops - 1: # If not last loop
                            
                            input_array[17] = int(125)
                            output = serialExecution(input_array)
                            board_output += output
                        
                        else: # If last loop set cycles to remaining   
                            
                            input_array[17] = int(remaining)
                            output = serialExecution(input_array)
                            board_output += output

                # Change units
                if unit == 'kOhm':
                    if byte14 == 4: # if read
                        convert_unit(board_output, byte8, byte16)
                    else: # if stop
                        convert_unit(board_output, byte8, byte8)
                        
            except Exception as e:
                
                print('Error: ' + str(e))
                msgBox['text'] = 'Board connection issue\nCheck if board is plugged in or if drivers not installed'
                outputBox["text"] = ""
        
        
        # If board requires reset -> display in message box, if not print output data and export it if enabled
        if board_output == 'reset switch':
            
            msgBox['text'] = 'Press reset switch to submit pulse'
        
        elif len(board_output) != 0:
    
            # Print output to box
            if unit == 'uA':
                out_str = "Current (uA):\n"
            if unit == 'kOhm':
                out_str = 'Resistance\n(kOhm):\n'
                
            for i in board_output[-4:]:
                out_str += str(i)+"\n"
            
            #displayed_output = [out_str, byte14, byte8, byte16] # [output as a string, read or stop, v_read1, v_read2]
            outputBox['text'] = out_str 
            msgBox["text"] = "" 
            
            # Print number of iterations when user achieves desired output
            if int(range_var.get()) == 1:
                msgBox["text"] = 'It took ' + str(iterations) + ' iterations to complete'
              
                
            # Exporting data to CSV file
            if int(csv_var.get()) == 1:
                
                if int(endurance_var.get()) == 1: # if endurance
                    arranged_data = arrange_endurance_export(device_output_list, byte6, byte14, byte18, byte4, byte12)
                elif int(range_var.get()) == 1: # if desired range
                    arranged_data = arrange_SD_export(attempt_list, byte6, byte14, byte18, byte20, byte19, byte4, byte12)
                else: # if single device
                    arranged_data = arrange_SD_export(board_output, byte6, byte14, byte18, byte20, byte19, byte4, byte12)

                export_csv(arranged_data, save_file_name_str, save_directory_str) # Export function
            
# function for clear button, clears output box and errors
def SD_clear_output():

    msgBox['text'] = ''
    outputBox['text'] = ''
    pulse1Time["bg"] = 'white'
    pulse1Voltage["bg"] = 'white'
    pulse1Blank["bg"] = 'white'
    pulse2Time["bg"] = 'white'
    pulse2Voltage["bg"] = 'white'
    pulse2Blank["bg"] = 'white'
    pulse3Time["bg"] = 'white'
    pulse3Voltage["bg"] = 'white'
    pulse3Blank["bg"] = 'white'
    pulse4Time["bg"] = 'white'
    pulse4Voltage["bg"] = 'white'
    pulse4Blank["bg"] = 'white'
    numCycles["bg"] = 'white'

# Runs when user switches between endurance and single device
def toggle_endurance():
    
    global windowNum
    
    if int(endurance_var.get()) == 1:
        
        windowNum = 4
        SD_button["state"] = NORMAL
        col_button["state"] = NORMAL
        vmm_button["state"] = NORMAL
        endurance_button["state"] = DISABLED
        SD_button["relief"] = RAISED
        col_button["relief"] = RAISED
        vmm_button["relief"] = RAISED
        endurance_button["relief"] = SUNKEN

        rowNum['state'] = DISABLED
        colNum['state'] = DISABLED
        subLabel['text'] = 'Endurance'

        min_output_range.config(state='disabled')
        max_output_range.config(state='disabled')
        n_range_entry.config(state='disabled')
        range_checkbox.config(state='disabled')
        range_checkbox.deselect()
        
    else:

        windowNum = 1
        SD_button["state"] = DISABLED
        col_button["state"] = NORMAL
        vmm_button["state"] = NORMAL
        endurance_button["state"] = NORMAL
        SD_button["relief"] = SUNKEN
        col_button["relief"] = RAISED
        vmm_button["relief"] = RAISED
        endurance_button["relief"] = RAISED
        
        subLabel['text'] = 'Single Device'
        rowNum['state'] = NORMAL
        colNum['state'] = NORMAL

        min_output_range.config(state='normal')
        max_output_range.config(state='normal')
        n_range_entry.config(state='normal')
        range_checkbox.config(state='normal')

# Toggles desired output range selection
def toggle_range():

    if int(range_var.get()) == 1:

        if int(endurance_var.get()) == 0:

            min_output_range.config(state='normal')
            max_output_range.config(state='normal')
            n_range_entry.config(state='normal')

    else:

        min_output_range.config(state='disabled')
        max_output_range.config(state='disabled')
        n_range_entry.config(state='disabled')

# Updates window based on pulse 1 selection
def update_pulse1(self):

    if b2.get() == "Form": # If chosen forming

        # Disable voltage input and set to 3.3
        b4.set("3.3")
        pulse1Voltage["state"] = DISABLED

        # Change pulse 3 to None
        pulse3Drop.config(state=DISABLED)
        b10.set('None')
        pulse3Voltage['state'] = DISABLED
        b12.set(0)
        pulse4Drop.config(state=DISABLED)
        b14.set('Stop')


        # Change pulse time to ms and set to 1
        b3.set("1")
        label1_3['text'] = 'ms'
        
    elif b2.get() == "None":
        
        b4.set("0")
        pulse1Voltage["state"] = DISABLED
        pulse3Drop.config(state=NORMAL)
        
    else: # If chosen set/reset
        
        if b2.get() == "Set":
            b4.set("2.5")
            
        else:
            b4.set("-1.5")
            
        pulse1Voltage['state'] = NORMAL
        b3.set('100')
        label1_3['text'] = 'us'

        # Change pulse 3 and 4 back
        pulse3Drop.config(state=NORMAL)
        pulse3Voltage['state'] = NORMAL
        b10.set('Reset')
        b12.set(-1.5)
        pulse4Drop.config(state=NORMAL)
        b14.set('Read')
         
# Updates window based on pulse 2 selection
def update_pulse2(self):        

    if b6.get() == "Stop":
        
        if b2.get() == "Form":
            pulse4Drop.config(state=NORMAL)

        pulse2Time['state'] = DISABLED
        pulse2Voltage['state'] = DISABLED
        pulse2Blank['state'] = DISABLED
        
        pulse1Drop.config(state=DISABLED)
        b2.set('None')
        pulse1Voltage['state'] = DISABLED
        b4.set(0)
        
    else: 

        pulse2Time['state'] = NORMAL
        pulse2Voltage['state'] = NORMAL
        pulse2Blank['state'] = NORMAL
        
        pulse1Drop.config(state=NORMAL)
        b2.set('Set')
        pulse1Voltage['state'] = NORMAL
        b4.set(2.5)

# Updates window based on pulse 3 selection 
def update_pulse3(self):
      
    if b10.get() == "None":
        
        b12.set("0")
        pulse3Voltage["state"] = DISABLED
          
    elif b10.get() == "Set":
        
        b12.set("2.5")
        pulse3Voltage["state"] = NORMAL
        
    else:
        
        b12.set("-1.5")
        pulse3Voltage["state"] = NORMAL
                 
# Updates window based on pulse 4 selection
def update_pulse4(self):                
        
    if b14.get() == "Stop":
        pulse4Time['state'] = DISABLED
        pulse4Voltage['state'] = DISABLED
        pulse4Blank['state'] = DISABLED
        
        pulse3Drop.config(state=DISABLED)
        b10.set('None')
        pulse3Voltage['state'] = DISABLED
        b12.set(0)
            
    else:
        pulse4Time['state'] = NORMAL
        pulse4Voltage['state'] = NORMAL
        pulse4Blank['state'] = NORMAL
        
        pulse3Drop.config(state=NORMAL)
        b10.set('Reset')
        pulse3Voltage['state'] = NORMAL
        b12.set(-1.5)
        
        
                
'''
-----------------------
Column Programming/VMM
-----------------------
Functions which are involved with performing Column Programming and VMM operation windows
'''
# Initializes opening the NEW VMM and OTHER OPERATIONS WINDOW lazypanda
#def open_NEW_VMM():
def open_NEW_VMM():
    global singleDevice_gui, columnBinary_gui, windowNum, vmm_checkbox
    
    SD_button["state"] = NORMAL
    col_button["state"] = NORMAL
    vmm_button["state"] = DISABLED
    endurance_button["state"] = NORMAL
    
    SD_button["relief"] = RAISED
    col_button["relief"] = RAISED
    vmm_button["relief"] = SUNKEN
    endurance_button["relief"] = RAISED
    
    # Close other operation windows and set window number
    if windowNum == 1:
        singleDevice_gui.destroy()
        columnBinary_window(TRUE)
    elif windowNum == 2:
        vmm_checkbox.select()
        toggle_vmm()
    elif windowNum == 3:
        print("window already open")
    elif windowNum == 4:
        singleDevice_gui.destroy()
        columnBinary_window(TRUE)
    else:
        columnBinary_window(TRUE)


# Initializes opening the column programming window
def open_ColumnBinary():

    global singleDevice_gui, columnBinary_gui, windowNum, vmm_checkbox
    
    SD_button["state"] = NORMAL
    col_button["state"] = DISABLED
    vmm_button["state"] = NORMAL
    endurance_button["state"] = NORMAL
    
    SD_button["relief"] = RAISED
    col_button["relief"] = SUNKEN
    vmm_button["relief"] = RAISED
    endurance_button["relief"] = RAISED
    
    # Close other operation windows and opens column window
    if windowNum == 1:
        singleDevice_gui.destroy()
        columnBinary_window(FALSE)
    elif windowNum == 2:
        print("window already open")
    elif windowNum == 3:
        vmm_checkbox.deselect()
        toggle_vmm()
    elif windowNum == 4:
        singleDevice_gui.destroy()
        columnBinary_window(FALSE)
    else:
        columnBinary_window(FALSE)

# Intitializes opening the vmm operation window
def open_VMM():

    global singleDevice_gui, columnBinary_gui, windowNum, vmm_checkbox
    
    SD_button["state"] = NORMAL
    col_button["state"] = NORMAL
    vmm_button["state"] = DISABLED
    endurance_button["state"] = NORMAL
    
    SD_button["relief"] = RAISED
    col_button["relief"] = RAISED
    vmm_button["relief"] = SUNKEN
    endurance_button["relief"] = RAISED
    
    # Close other operation windows and set window number
    if windowNum == 1:
        singleDevice_gui.destroy()
        columnBinary_window(TRUE)
    elif windowNum == 2:
        vmm_checkbox.select()
        toggle_vmm()
    elif windowNum == 3:
        print("window already open")
    elif windowNum == 4:
        singleDevice_gui.destroy()
        columnBinary_window(TRUE)
    else:
        columnBinary_window(TRUE)

# Default column programming/vmm window
def columnBinary_window(vmm):
       
    global b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, csv_var, vmm_toggle, vmm_cycle
    global column1, column2, column3, column4, column5, column6, column7, column8
    global frame1, frame2, frame3, frame4, frame5
    global columnBinary_gui, windowNum, v_read  
    global unit_button, unit
    
    windowNum = 2
    v_read = []
    
    columnBinary_gui = Toplevel(master)
    
    columnBinary_gui.title("Column Programming/Vmm Operation")
    
    col_canvas = Canvas(columnBinary_gui, width=650, height=650)
    col_canvas.grid(rowspan=20,columnspan=4) # separates window into N number of equally spaced columns/rows 
    
    columnBinary_gui.resizable(False,False)
    columnBinary_gui.protocol("WM_DELETE_WINDOW", on_closing)
    
    # Add SUNY Poly Logo
    # logo = Image.open('C:\Users\jpelt\Desktop\exe\poly_logo.png')
    # logo = logo.resize((300,50), Image.Resampling.LANCZOS)
    # logo = ImageTk.PhotoImage(logo)
    # logo_label = Label(columnBinary_gui, image=logo)
    # logo_label.image = logo
    # logo_label.place(relx=0.48, rely=0.05)

    # Declare column memory as lists
    column1 = [[0],[0]] # [[outputs], [device states]]
    column2 = [[0],[0]]
    column3 = [[0],[0]]
    column4 = [[0],[0]]
    column5 = [[0],[0]]
    column6 = [[0],[0]]
    column7 = [[0],[0]]
    column8 = [[0],[0]]

    # Declare input variables (bytes 2-20)
    b2 = StringVar()
    b3 = StringVar()
    b4 = StringVar()
    b5 = StringVar()
    b6 = StringVar()
    b7 = StringVar()
    b8 = StringVar()
    b9 = StringVar()
    b10 = StringVar()
    b11 = StringVar()
    b12 = StringVar()
    b13 = StringVar()
    b14 = StringVar()
    b15 = StringVar()
    b16 = StringVar()
    b17 = StringVar()
    b18 = StringVar()
    b19 = StringVar()
    b20 = StringVar()

    csv_var = IntVar()
    vmm_toggle = IntVar()
    vmm_cycle = IntVar()
    
    # Default values for each byte
    b2.set("100")
    b3.set("2.5")
    b4.set("-1.5")
    b5.set("100")
    b6.set("100")
    b7.set("-0.2")
    b8.set("100")
    b9.set("0")
    b10.set("0")
    b11.set("0")
    b12.set("0")
    b13.set("0")
    b14.set("0")
    b15.set("0")
    b16.set("0")
    b17.set("0")
    b18.set("1")
    b19.set("1")
    b20.set("0")
    

    # Title Labels
    titleLabel = Label(columnBinary_gui, text="ReRam Testing", font = ('calibre',20, 'bold'))
    titleLabel.place(relx=0.1, rely=0.05)

    global subLabel
    subLabel = Label(columnBinary_gui, text="Column Programming", font = ('calibre',14,'normal'))
    subLabel.place(relx=0.105, rely=0.12) 
    
    # Binary Pulse Setup
    # --------------------
    # Frame
    frame1 = LabelFrame(columnBinary_gui, text="Binary Pulse Setup", padx=10, pady=10)
    frame1.place(relx=0.1, rely=0.18)

    # Labels for inputs
    col_label1_1 = Label(frame1, text="Set/Reset Pulse Time:").grid(row=2, column=0, padx=10)
    col_label1_2 = Label(frame1, text="Set Voltage:").grid(row=0, column=0, padx=10)
    col_label1_3 = Label(frame1, text="Reset Voltage").grid(row=1, column=0)
    col_label1_4 = Label(frame1, text="Set/Reset Blank Time:").grid(row=3, column=0, padx=10)
    col_label1_5 = Label(frame1, text="us").grid(row=2, column=2, padx=5)
    col_label1_6 = Label(frame1, text="V").grid(row=0, column=2, padx=5)
    col_label1_7 = Label(frame1, text="V").grid(row=1, column=2, padx=5)
    col_label1_8 = Label(frame1, text="us").grid(row=3, column=2, padx=5)
    
    # Input fields 
    global setResetTime, setVoltage, resetVoltage, blankTime
    
    setResetTime = Entry(frame1, width=5, textvariable=b2, font = ('calibre',10,'normal'), bg="white")
    setResetTime.grid(row=2, column=1)

    setVoltage = Entry(frame1, width=5, textvariable=b3, font = ('calibre',10,'normal'), bg="white")
    setVoltage.grid(row=0, column=1)

    resetVoltage= Entry(frame1, width=5, textvariable=b4, font = ('calibre',10,'normal'), bg="white")
    resetVoltage.grid(row=1, column=1)
    
    blankTime = Entry(frame1, width=5, textvariable=b5, font = ('calibre',10,'normal'), bg="white")
    blankTime.grid(row=3, column=1)
    
    
    # Read Pulse Setup
    # --------------------
    # Frame 2
    frame2 = LabelFrame(columnBinary_gui, text="Read Pulse Setup", padx=10, pady=10)
    frame2.place(relx=0.1, rely=0.39)
    
    # Labels for inputs
    col_label2_1 = Label(frame2, text="Read Pulse Time:").grid(row=0, column=0, padx=10)
    col_label2_2 = Label(frame2, text="Read Voltage:").grid(row=1, column=0, padx=10)
    col_label2_3 = Label(frame2, text="Read Blank Time:").grid(row=2, column=0, padx=10)
    col_label2_4 = Label(frame2, text="us").grid(row=0, column=2, padx=5)
    col_label2_5 = Label(frame2, text="V").grid(row=1, column=2, padx=5)
    col_label2_6 = Label(frame2, text="us").grid(row=2, column=2, padx=5)
    
    # Input fields 
    global readTime, readVoltage, readBlankTime
    
    readTime = Entry(frame2, width=5, textvariable=b6, font = ('calibre',10,'normal'), bg="white")
    readTime.grid(row=0, column=1)

    readVoltage = Entry(frame2, width=5, textvariable=b7, font = ('calibre',10,'normal'), bg="white")
    readVoltage.grid(row=1, column=1)

    readBlankTime= Entry(frame2, width=5, textvariable=b8, font = ('calibre',10,'normal'), bg="white")
    readBlankTime.grid(row=2, column=1)
    
    # Device States
    # -----------------
    # Frame 3
    frame3 = LabelFrame(columnBinary_gui, text="Device States", padx=10, pady=10)
    frame3.place(relx=0.52, rely=0.24)
    
    # Labels for inputs
    global key_label, col_label_unit
    col_label3_1 = Label(frame3, text="Device 1:").grid(row=1, column=0, padx=10)
    col_label3_2 = Label(frame3, text="Device 2:").grid(row=2, column=0, padx=10)
    col_label3_3 = Label(frame3, text="Device 3:").grid(row=3, column=0, padx=10)
    col_label3_4 = Label(frame3, text="Device 4:").grid(row=4, column=0, padx=10)
    col_label3_5 = Label(frame3, text="Device 5:").grid(row=5, column=0, padx=10)
    col_label3_6 = Label(frame3, text="Device 6:").grid(row=6, column=0, padx=10)
    col_label3_7 = Label(frame3, text="Device 7:").grid(row=7, column=0, padx=10)
    col_label3_8 = Label(frame3, text="Device 8:").grid(row=8, column=0, padx=10)
    col_label_unit = Label(frame3, text="Output (" + unit + "):")
    col_label_unit.grid(row=0, column=2)
    key_label = Label(columnBinary_gui, text="1 = Set      0 = Reset")
    key_label.place(relx=0.74, rely=0.21)
    
    # Dropdowns for inputs
    global device1, device2, device3, device4, device5, device6, device7, device8
    
    device1 = Button(frame3, text='0', width=5, height=1, command=lambda:toggle_device_state(b9, device1))
    device1.grid(row=1, column=1)
    
    device2 = Button(frame3, text='0', width=5, height=1, command=lambda:toggle_device_state(b10, device2))
    device2.grid(row=2, column=1)
    
    device3 = Button(frame3, text='0', width=5, height=1, command=lambda:toggle_device_state(b11, device3))
    device3.grid(row=3, column=1)
    
    device4 = Button(frame3, text='0', width=5, height=1, command=lambda:toggle_device_state(b12, device4))
    device4.grid(row=4, column=1)
    
    device5 = Button(frame3, text='0', width=5, height=1, command=lambda:toggle_device_state(b13, device5))
    device5.grid(row=5, column=1)
    
    device6 = Button(frame3, text='0', width=5, height=1, command=lambda:toggle_device_state(b14, device6))
    device6.grid(row=6, column=1)
    
    device7 = Button(frame3, text='0', width=5, height=1, command=lambda:toggle_device_state(b15, device7))
    device7.grid(row=7, column=1)
    
    device8 = Button(frame3, text='0', width=5, height=1, command=lambda:toggle_device_state(b16, device8))
    device8.grid(row=8, column=1)
    
    global out1, out2, out3, out4, out5, out6, out7, out8
    out1 = Label(frame3, text=" ", bd=1, relief=SUNKEN, pady=5, height=1, width=8, bg="light gray")
    out1.grid(row=1, column=2, padx=30)
    out2 = Label(frame3, text=" ", bd=1, relief=SUNKEN, pady=5, height=1, width=8, bg="light gray")
    out2.grid(row=2, column=2, padx=30)
    out3 = Label(frame3, text=" ", bd=1, relief=SUNKEN, pady=5, height=1, width=8, bg="light gray")
    out3.grid(row=3, column=2, padx=30)
    out4 = Label(frame3, text=" ", bd=1, relief=SUNKEN, pady=5, height=1, width=8, bg="light gray")
    out4.grid(row=4, column=2, padx=30)
    out5 = Label(frame3, text=" ", bd=1, relief=SUNKEN, pady=5, height=1, width=8, bg="light gray")
    out5.grid(row=5, column=2, padx=30)
    out6 = Label(frame3, text=" ", bd=1, relief=SUNKEN, pady=5, height=1, width=8, bg="light gray")
    out6.grid(row=6, column=2, padx=30)
    out7 = Label(frame3, text=" ", bd=1, relief=SUNKEN, pady=5, height=1, width=8, bg="light gray")
    out7.grid(row=7, column=2, padx=30)
    out8 = Label(frame3, text=" ", bd=1, relief=SUNKEN, pady=5, height=1, width=8, bg="light gray")
    out8.grid(row=8, column=2, padx=30)

    global total_out, total_label2
    total_label1 = Label(columnBinary_gui, text="Total Current:").place(relx=0.635, rely=0.683)
    total_label2 = Label(columnBinary_gui, text="uA")
    total_label2.place(relx=0.87, rely=0.683)
    total_out = Label(columnBinary_gui, text=" ", bd=1, relief=SUNKEN, pady=5, height=1, width=8, bg="light gray")
    total_out.place(relx=0.765,rely=0.68)


    # Column/Cycles Selection
    # Frame 4
    frame4 = LabelFrame(columnBinary_gui, text="Column Select/Cycles", padx=10, pady=10)
    frame4.place(relx=0.1, rely=0.57)
    
    col_label4_1 = Label(frame4, text="Column for Operation:").grid(row=0, column=0, padx=10)
    col_label4_1 = Label(frame4, text="Number of Cycles:").grid(row=1, column=0, padx=10)
    
    colNum_Drop = OptionMenu(frame4, b19, "1", "2", "3", "4", "5", "6", "7", "8", command=change_column)
    colNum_Drop.grid(row=0, column=1)

    global col_numCycles
    col_numCycles = Entry(frame4, width=5, textvariable=b18, font = ('calibre',10,'normal'), bg="white")
    col_numCycles.grid(row=1, column=1, padx=2, pady=5)

    # Checkbox Frame
    # Frame 5
    frame5 = LabelFrame(columnBinary_gui, padx=10, pady=10)
    frame5.place(relx=0.1, rely=0.75)
    
    # Exporting Checkbox
    exp_csv = Checkbutton(frame5, text="Export to CSV file", variable=csv_var)
    exp_csv.grid(row=0, column=2)

    # VMM Cycle Checkbox
    global vmm_cycle_checkbox
    vmm_cycle_checkbox = Checkbutton(frame5, text="Binary VMM Loop", variable=vmm_cycle, command=toggle_binary_vmm_cycle, padx=8)
    vmm_cycle_checkbox.grid(row=0, column=1)

    # VMM Checkbox
    global vmm_checkbox
    vmm_checkbox = Checkbutton(frame5, text="Toggle VMM", variable=vmm_toggle, command=toggle_vmm)
    vmm_checkbox.grid(row=0, column=0)
        
    # Unit button
    unit_label = Label(columnBinary_gui, text="Unit:").place(relx=0.795, rely=0.79)
    unit_button = Button(columnBinary_gui, text=unit, command=toggle_unit, width=5, padx=2, pady=1, bg="light gray")
    unit_button.place(relx=0.85,rely=0.785)

    
    # Clear button
    col_clear_button = Button(columnBinary_gui, text="Clear", command=col_clear_output, height=4, width=6, bg="white")
    col_clear_button.place(relx=0.75,rely=0.86)

    # Pulse Generator
    # ---------------
    # global pulseGen_button
    # waveImg2 = waveImg.resize((40,30), Image.Resampling.LANCZOS)
    # waveImg2 = ImageTk.PhotoImage(waveImg2)
    # pulseGen_button = Button(columnBinary_gui, image=waveImg2, command=col_pulseGen_window)
    # pulseGen_button.image = waveImg2
    # pulseGen_button.place(relx=0.49, rely=0.705)
    
    # Change column states
    all_ones_button = Button(columnBinary_gui, text="All 1", command=lambda:set_column_states('ones'), height=1, width=5, bg="light gray")
    all_ones_button.place(relx=0.56,rely=0.18)
    all_zeros_button = Button(columnBinary_gui, text="All 0", command=lambda:set_column_states('zeros'), height=1, width=5, bg="light gray")
    all_zeros_button.place(relx=0.64,rely=0.18)

    # Submit button
    col_submit_button = Button(columnBinary_gui, text="Send ", command=col_submit_data, height=4, width=10, bg="white")
    col_submit_button.place(relx=0.85,rely=0.86)

    # Message box
    global msgBox
    msgBox = Label(columnBinary_gui, text="", bd=1, relief=SUNKEN, pady=5, height=4, width=60, bg="light gray") 
    msgBox.place(relx=0.07, rely=0.86)
    
    if vmm == TRUE:
        vmm_checkbox.select()
        toggle_vmm()
 
# Initializes sending the pulse parameters to the PCB board
def col_submit_data():
    
    if int(vmm_toggle.get()) == 0:
        submit_columnOp()
    else:
        submit_vmmOp(None)
    
# Submits all parameters in column programming to organize into correct order and then send to PCB board                
def submit_columnOp():

    global out1, out2, out3, out4, out5, out6, out7, out8
    global save_directory_str, save_file_name_str
    global v_read
    
    # Get byte values as floats
    # ---------------------------
    
    # Binary Pulse setup
    byte2 = float(b2.get())
    byte3 = float(b3.get())
    byte4 = float(b4.get())
    byte5 = float(b5.get())
    
    # Read pulse setup
    byte6 = float(b6.get())
    byte7 = float(b7.get())
    byte8 = float(b8.get())
    
    # Device states
    byte9 = float(b9.get())
    byte10 = float(b10.get())
    byte11 = float(b11.get())
    byte12 = float(b12.get())
    byte13 = float(b13.get())
    byte14 = float(b14.get())
    byte15 = float(b15.get())
    byte16 = float(b16.get())
    
    # Rest of bytes
    byte17 = float(0)
    byte18 = float(b18.get()) # cycles
    byte19 = float(b19.get())
    byte20 = float(0)
    
    v_read = [byte7, byte7]
    
    # Function to check if values are in proper range and placed in order
    input_array = col_check_and_order(byte2, byte3, byte4, byte5, byte6, byte7, byte8, byte9, byte10, byte11, byte12, byte13, byte14, byte15, byte16, byte17, byte18, byte19, byte20)

    # If returns error list print errors to output box
    if input_array[0] == "error":
        
        for n in input_array:
            if n == 'error':
                i = n
            else:
                i = int(n)
            # Binary pulse setup
            if i == 2:
                setResetTime["bg"] = 'red'
            if i == 3:
                setVoltage["bg"] = 'red'
            if i == 4:
                resetVoltage["bg"] = 'red'
            if i == 5:
                blankTime["bg"] = 'red'
            # Read pulse setup
            if i == 6:
                readTime["bg"] = 'red'
            if i == 7:
                readVoltage["bg"] = 'red'
            if i == 8:
                readBlankTime["bg"] = 'red'

            msgBox["text"] = "Cannot submit pulse wave for Column Programming\nAll red values are out of range\nPress clear to remove"

            
    else: # if no error send ordered bytes to PCB board
        
        msgBox['text'] = ''
        setResetTime["bg"] = 'white'
        setVoltage["bg"] = 'white'
        resetVoltage["bg"] = 'white'
        blankTime["bg"] = 'white'
        readTime["bg"] = 'white'
        readVoltage["bg"] = 'white'
        readBlankTime["bg"] = 'white'
        
        board_output = []

        if byte18 > 1 and vmm_cycle.get() == 0: # if multiple column programming cycles and binary vmm cycle disabled
            
            for i in range(int(byte18)):
            
                try:

                    # Send byte sequence to board
                    raw_board_output = serialExecution(input_array)

                    # Change units
                    if unit == 'kOhm':
                        convert_unit(raw_board_output, byte7, byte7)

                    board_output.append(raw_board_output)
                    
                except Exception as e:
            
                    print(e)
                    msgBox['text'] = 'Board connection issue\n Check if board is plugged in or if drivers not installed'
        
        else: # if only 1 cycle
            
            try:

                # Send byte sequence to board
                raw_board_output = serialExecution(input_array)

                # Change units
                if unit == 'kOhm':
                    convert_unit(raw_board_output, byte7, byte7)
                    
                board_output.append(raw_board_output)

            except Exception as e:
        
                print(e)
                msgBox['text'] = 'Board connection issue\n Check if board is plugged in or if drivers not installed'
    
        # If binary vmm cycle complete VMM
        if vmm_cycle.get() == 1:
            submit_vmmOp(board_output)
        
    # If board requires reset display in message box, if not print output data
    if board_output == 'reset switch':
        
        msgBox['text'] = 'Press reset switch to submit pulse'
        
    elif len(board_output) != 0:
        
        store_column_data(byte19, board_output[-1], [byte9, byte10, byte11, byte12, byte13, byte14, byte15, byte16])
        print_to_columns([board_output[-1], [byte9, byte10, byte11, byte12, byte13, byte14, byte15, byte16]])
        
        # Exporting data to CSV file
        if int(csv_var.get()) == 1 and vmm_cycle.get() == 0:
            
            arranged_data = arrange_column_export(board_output, byte19, [byte9, byte10, byte11, byte12, byte13, byte14, byte15, byte16])
            export_csv(arranged_data, save_file_name_str, save_directory_str)
                
# Submits all parameters in vmm operation to organize into correct order and then send to PCB board
def submit_vmmOp(col_data):
    
    global out1, out2, out3, out4, out5, out6, out7, out8
    global save_directory_str, save_file_name_str
    
    # Get byte values as floats
    # ---------------------------
    
    # Dont care
    byte2 = float(0)
    byte3 = float(0)
    byte4 = float(0)
    byte5 = float(0)
    
    # Read pulse setup
    byte6 = float(b6.get())
    byte7 = float(b7.get())
    byte8 = float(0)
    
    # Device states
    byte9 = float(b9.get())
    byte10 = float(b10.get())
    byte11 = float(b11.get())
    byte12 = float(b12.get())
    byte13 = float(b13.get())
    byte14 = float(b14.get())
    byte15 = float(b15.get())
    byte16 = float(b16.get())
    
    # Rest of bytes
    byte17 = float(0)
    byte18 = float(b18.get())
    byte19 = float(b19.get())
    byte20 = float(9)


    input_array = vmm_check_and_order(byte2, byte3, byte4, byte5, byte6, byte7, byte8, byte9, byte10, byte11, byte12, byte13, byte14, byte15, byte16, byte17, byte18, byte19, byte20)

    # If returns error list print errors to output box
    if input_array[0] == "error":
        
        for n in input_array:
            if n == 'error':
                i = n
            else:
                i = int(n)
            # Binary pulse setup
            if i == 6:
                readTime["bg"] = 'red'
            if i == 7:
                readVoltage["bg"] = 'red'
            if i == 18:
                col_numCycles["bg"] = 'red'

            msgBox["text"] = "Cannot submit pulse wave for VMM operation\nAll red values are out of range\nPress clear to remove"

            
    else: # if no error 
        

        if int(vmm_cycle.get()) == 1: # VMM Cycle through all 256 binary combinations

            binary_list = get_binary_list()
            msgBox['text'] = 'This may take some time, please be patient'
            vmm_output_list = []

            # Loop through all possible binary combinations
            for i in range(len(binary_list)):

                index = 8 # start index for read states

                for state in binary_list[i]: # set byte values to 0 or 1 based on binary value
                    input_array[index] = int(state)
                    index += 1

                try:

                    # Send byte array to board through serial
                    if byte18 <= 125: # If cycles less than 125 run normal serial execution

                        board_output = serialExecution(input_array)
                        
                    else: # If cycles greater than 125 then loop through serial executions of 125 until last loop then do remaining cycles
                        
                        loops = floor(byte18/125) + 1 # Number of loops of 125 cycles
                        remaining = (byte18 % 125) # Remaining cycles at last loop
                        board_output = []
                        
                        for i in range(loops):
                            
                            if i != loops - 1: # If not last loop
                                
                                input_array[17] = int(125)
                                output = serialExecution(input_array)
                                board_output += output
                            
                            else: # If last loop set cycles to remaining   
                                
                                input_array[17] = int(remaining)
                                output = serialExecution(input_array)
                                board_output += output

                except Exception as e:
                        
                    msgBox['text'] = 'Board connection issue\nCheck if board is plugged in or if drivers not installed'
                    outputBox["text"] = ""
                        
                vmm_output_list.append(board_output)

        else: # Normal VMM

            try:

                # Send byte array to board through serial
                if byte18 <= 125: # If cycles less than 125 run normal serial execution
                    
                    board_output = serialExecution(input_array)
                    
                else: # If cycles greater than 125 then loop through serial executions of 125 until last loop then do remaining cycles
                    
                    loops = floor(byte18/125) + 1 # Number of loops of 125 cycles
                    remaining = (byte18 % 125) # Remaining cycles at last loop
                    board_output = []
                    
                    for i in range(loops):
                        
                        if i != loops - 1: # If not last loop
                            
                            input_array[17] = int(125)
                            output = serialExecution(input_array)
                            board_output += output
                        
                        else: # If last loop set cycles to remaining   
                            
                            input_array[17] = int(remaining)
                            output = serialExecution(input_array)
                            board_output += output
                        
            except Exception as e:
                
                print('Error: ' + str(e))
                msgBox['text'] = 'Board connection issue\nCheck if board is plugged in or if drivers not installed'
                outputBox["text"] = ""


    
        # If board requires reset display in message box, if not print output data
        if board_output == 'reset switch':
            
            msgBox['text'] = 'Press reset switch to submit pulse'
            
        elif len(board_output) != 0:
        
            # Clear errors
            msgBox['text'] = ''
            readTime["bg"] = 'white'
            readVoltage["bg"] = 'white'
            col_numCycles["bg"] = 'white'

            # Print to total output
            out_str = str(board_output[0])
            total_out['text'] = out_str
            
            
            # Exporting data to CSV file
            if int(csv_var.get()) == 1:
                
                if int(vmm_cycle.get()) == 1:
                    
                    arranged_data = arrange_vmm_cycle_export(vmm_output_list, byte18, byte19, binary_list)
                    
                    if col_data != None: # if there is column data to combine

                        arranged_data1 = arrange_column_export(col_data, byte19, [byte9, byte10, byte11, byte12, byte13, byte14, byte15, byte16])
                        arranged_data1 += [''] # create excel spacer
                        arranged_data1 += ['']
                        arranged_data1 += ['']

                        arranged_data = arranged_data1 + arranged_data # combine arranged data from column programming and binary vmm

                else:
                    
                    arranged_data = arrange_vmm_export(board_output, byte18, byte19)
                
                export_csv(arranged_data, save_file_name_str, save_directory_str)
            
# Occurs when user switches to VMM operation
def toggle_vmm():

    global windowNum, unit

    if int(vmm_toggle.get()) == 1:

        windowNum = 3
        SD_button["state"] = NORMAL
        col_button["state"] = NORMAL
        vmm_button["state"] = DISABLED
        SD_button["relief"] = RAISED
        col_button["relief"] = RAISED
        vmm_button["relief"] = SUNKEN

        subLabel['text'] = 'VMM Operation'
        setResetTime['state'] = DISABLED
        setVoltage['state'] = DISABLED
        resetVoltage['state'] = DISABLED
        blankTime['state'] = DISABLED
        readBlankTime['state'] = DISABLED
        #col_numCycles['state'] = NORMAL
        if vmm_cycle.get() == 1:
            device1['state'] = DISABLED
            device2['state'] = DISABLED
            device3['state'] = DISABLED
            device4['state'] = DISABLED
            device5['state'] = DISABLED
            device6['state'] = DISABLED
            device7['state'] = DISABLED
            device8['state'] = DISABLED
        frame3['text'] = 'Read States'
        key_label['text'] = "1 = Read    0 = None"
        b7.set("-0.2")
        
        col_data = get_column_data(int(b19.get()))
        print_to_columns(col_data)

    else:

        windowNum = 2
        SD_button["state"] = NORMAL
        col_button["state"] = DISABLED
        vmm_button["state"] = NORMAL
        SD_button["relief"] = RAISED
        col_button["relief"] = SUNKEN
        vmm_button["relief"] = RAISED

        subLabel['text'] = 'Column Programming'
        setResetTime['state'] = NORMAL
        setVoltage['state'] = NORMAL
        resetVoltage['state'] = NORMAL
        blankTime['state'] = NORMAL
        readBlankTime['state'] = NORMAL
        if vmm_cycle.get() == 1:
            device1['state'] = NORMAL
            device2['state'] = NORMAL
            device3['state'] = NORMAL
            device4['state'] = NORMAL
            device5['state'] = NORMAL
            device6['state'] = NORMAL
            device7['state'] = NORMAL
            device8['state'] = NORMAL
        frame3['text'] = 'Device States'
        key_label['text'] = "1 = Set      0 = Reset"
        b7.set("-0.2")
        
        col_data = get_column_data(int(b19.get()))
        print_to_columns(col_data)  
        
# Occurs when toggling Binary VMM cycle checkbox
def toggle_binary_vmm_cycle():

    if vmm_cycle.get() == 1:

        msgBox['text'] = 'Enabled Binary VMM Loop\nIf column programming, VMM loop will run directly after the column is\nprogrammed. If VMM is enabled, VMM loop runs as its own operation'

        if vmm_toggle.get() == 1:

            device1['state'] = DISABLED
            device2['state'] = DISABLED
            device3['state'] = DISABLED
            device4['state'] = DISABLED
            device5['state'] = DISABLED
            device6['state'] = DISABLED
            device7['state'] = DISABLED
            device8['state'] = DISABLED
    
    else:

        msgBox['text'] = ''

        if vmm_toggle.get() == 1:

            device1['state'] = NORMAL
            device2['state'] = NORMAL
            device3['state'] = NORMAL
            device4['state'] = NORMAL
            device5['state'] = NORMAL
            device6['state'] = NORMAL
            device7['state'] = NORMAL
            device8['state'] = NORMAL

# Prints the values from the PCB board to the GUI
def print_to_columns(column):
    
    if len(column[1]) == 1 and int(vmm_toggle.get()) == 0:
        
        set_column_states('zeros')
    
    if len(column[0]) == 1:

        out1['text'] = ''
        out2['text'] = ''
        out3['text'] = ''
        out4['text'] = ''
        out5['text'] = ''
        out6['text'] = ''
        out7['text'] = ''
        out8['text'] = ''
        
    else:

        for i in range(array_size):

            if i == 0:
                out1['text'] = str(column[0][i])
                if int(vmm_toggle.get()) == 0:
                    device1['text'] = str(int(column[1][i]))
            if i == 1:
                out2['text'] = str(column[0][i])
                if int(vmm_toggle.get()) == 0:
                    device2['text'] = str(int(column[1][i]))
            if i == 2:
                out3['text'] = str(column[0][i])
                if int(vmm_toggle.get()) == 0:
                    device3['text'] = str(int(column[1][i]))
            if i == 3:
                out4['text'] = str(column[0][i])
                if int(vmm_toggle.get()) == 0:
                    device4['text'] = str(int(column[1][i]))
            if i == 4:
                out5['text'] = str(column[0][i])
                if int(vmm_toggle.get()) == 0:
                    device5['text'] = str(int(column[1][i]))
            if i == 5:
                out6['text'] = str(column[0][i])
                if int(vmm_toggle.get()) == 0:
                    device6['text'] = str(int(column[1][i]))
            if i == 6:
                out7['text'] = str(column[0][i])
                if int(vmm_toggle.get()) == 0:                   
                    device7['text'] = str(int(column[1][i]))
            if i == 7:
                out8['text'] = str(column[0][i])
                if int(vmm_toggle.get()) == 0:
                    device8['text'] = str(int(column[1][i]))

# Inserts output values on columns previously programmed
def change_column(self):

    byte19 = float(b19.get())

    if byte19 == 1:
        print_to_columns(column1)
    if byte19 == 2:
        print_to_columns(column2)
    if byte19 == 3:
        print_to_columns(column3)
    if byte19 == 4:
        print_to_columns(column4)
    if byte19 == 5:
        print_to_columns(column5)
    if byte19 == 6:
        print_to_columns(column6)
    if byte19 == 7:
        print_to_columns(column7)
    if byte19 == 8:
        print_to_columns(column8)

# Clear outputs in column/vmm window
def col_clear_output():
    
    out1['text'] = ''
    out2['text'] = ''
    out3['text'] = ''
    out4['text'] = ''
    out5['text'] = ''
    out6['text'] = ''
    out7['text'] = ''
    out8['text'] = ''
    
    setResetTime["bg"] = 'white'
    setVoltage["bg"] = 'white'
    resetVoltage["bg"] = 'white'
    blankTime["bg"] = 'white'
    readTime["bg"] = 'white'
    readVoltage["bg"] = 'white'
    readBlankTime["bg"] = 'white'

    msgBox['text'] = ''
    total_out['text'] = ''

# Store outputs for each column 
def store_column_data(byte19, board_output, device_states):
    
    if byte19 == 1:
        column1.clear()
        column1.append(board_output)
        column1.append(device_states)
    if byte19 == 2:
        column2.clear()
        column2.append(board_output)
        column2.append(device_states)
    if byte19 == 3:
        column3.clear()
        column3.append(board_output)
        column3.append(device_states)
    if byte19 == 4:
        column4.clear()
        column4.append(board_output)
        column4.append(device_states)
    if byte19 == 5:
        column5.clear()
        column5.append(board_output)
        column5.append(device_states)
    if byte19 == 6:
        column6.clear()
        column6.append(board_output)
        column6.append(device_states)
    if byte19 == 7:
        column7.clear()
        column7.append(board_output)
        column7.append(device_states)
    if byte19 == 8:
        column8.clear()
        column8.append(board_output)
        column8.append(device_states)
        
# Toggles device states between 0 and 1
def toggle_device_state(byte, device):
    
    if int(byte.get()) == 0:
        
        byte.set('1')
        device['text'] = '1'
    
    else:
        
        byte.set('0')
        device['text'] = '0'
         
# Sets the device states to all set or reset
def set_column_states(choice):
    
    if choice == 'zeros':
        
        b9.set("0")
        b10.set("0")
        b11.set("0")
        b12.set("0")
        b13.set("0")
        b14.set("0")
        b15.set("0")
        b16.set("0")
        
        device1['text'] = '0'
        device2['text'] = '0'
        device3['text'] = '0'
        device4['text'] = '0'
        device5['text'] = '0'
        device6['text'] = '0'
        device7['text'] = '0'
        device8['text'] = '0'
    
    elif choice == 'ones':
        
        b9.set("1")
        b10.set("1")
        b11.set("1")
        b12.set("1")
        b13.set("1")
        b14.set("1")
        b15.set("1")
        b16.set("1")
        
        device1['text'] = '1'
        device2['text'] = '1'
        device3['text'] = '1'
        device4['text'] = '1'
        device5['text'] = '1'
        device6['text'] = '1'
        device7['text'] = '1'
        device8['text'] = '1'

# Returns column data based on column number chosen 
def get_column_data(col):
    
    if col == 1:
        return column1
    if col == 2:
        return column2
    if col == 3:
        return column3
    if col == 4:
        return column4
    if col == 5:
        return column5
    if col == 6:
        return column6
    if col == 7:
        return column7
    if col == 8:
        return column8

# Gets list of binary numbers from 0-256
def get_binary_list():

    binary_list = []

    for i in range(256):

        val = bin(i)
        val = val.replace('0b', '')
        prenum = ''

        if len(val) < 8:
            loop = 8 - len(val)

            for i in range(loop):
                prenum += '0'

        new_val = prenum + val
        binary_list.append(str(new_val))

    return binary_list



'''
----------------
Profile Manager
----------------
Functions which deal with the profile manager window
'''
# Initialize opening the profile manager
def init_profile_manager():
    
    global profile_manager_window
    
    try:
        
        if profile_manager_window.state() == 'normal':
            
            print('already open')
        
    except:
        
        open_profile_manager()

# Opens the window for profile manager
def open_profile_manager():

    global profile_manager_window, profile_directory, selected_profile, profile_name_to_add
    
    profile_manager_window = Toplevel(master)
    profile_manager_window.title("Profile Manager")
    profile_manager_window.geometry("550x200")
    profile_manager_window.resizable(False,False)
    
    # Declare variables
    selected_profile = StringVar()
    profile_directory = StringVar()
    profile_name_to_add = StringVar()
    
    # Labels
    global profile_error_label
    directory_label = Label(profile_manager_window, text="Profile Folder:", padx=8).place(relx=0.03, rely=0.06)
    profile_label = Label(profile_manager_window, text="Profile List:", padx=8).place(relx=0.06, rely=0.25)
    horiz_line = Label(profile_manager_window, text="_______________________________________________________________________________________________________").place(relx=0.03, rely=0.48)
    profile_name_label = Label(profile_manager_window, text="Profile Name to Add:", padx=8).place(relx=0.03, rely=0.65)
    profile_name_label2 = Label(profile_manager_window, text="* Adding a new profile takes paramters from operation window currently open *", padx=8).place(relx=0.08, rely=0.82)
    profile_name_label = Label(profile_manager_window, text=".txt", padx=8).place(relx=0.52, rely=0.65)
    profile_error_label = Label(profile_manager_window, text="", fg='red')
    profile_error_label.place(relx=0.12, rely=0.42)
    
    # Message box
    global profile_dirBox
    profile_dirBox = Entry(profile_manager_window, width=45, textvariable=profile_directory, font = ('calibre',10,'normal'), bg="white")
    profile_dirBox.place(relx=0.2, rely=0.06)
    profile_dirBox.insert(0, 'profiles')
    
    # Profile Dropdown
    global profile_menu, profiles
    profiles = get_profiles('profiles')
    profile_menu = OptionMenu(profile_manager_window, selected_profile, *profiles)
    profile_menu.place(relx=0.205, rely=0.22)
    profile_menu.config(width=20)
    selected_profile.set('Default Single Device.txt')
    
    # Profile directory Button
    global change_profile_dir
    change_profile_dir = Button(profile_manager_window, text="Change Dir", command=choose_profile_directory, height=1, width=10, bg="white")
    change_profile_dir.place(relx=0.8, rely=0.045)
    
    # Manager Buttons
    global update_profile_button, delete_profile_button, load_profile_button, add_profile_button
    load_profile_button = Button(profile_manager_window, text="Load", command=load_profile, height=1, width=8, bg="white")
    load_profile_button.place(relx=0.55, rely=0.26)
    update_profile_button = Button(profile_manager_window, text="Update", command=lambda:confirm_delete_or_update('update'), height=1, width=8, bg="white")
    update_profile_button.place(relx=0.7, rely=0.26)
    delete_profile_button = Button(profile_manager_window, text="Delete", command=lambda:confirm_delete_or_update('delete'), height=1, width=8, bg="white")
    delete_profile_button.place(relx=0.85, rely=0.26)
    add_profile_button = Button(profile_manager_window, text="Add Profile", command=lambda:add_or_update_profile('add'), height=1, width=11, bg="white")
    add_profile_button.place(relx=0.7, rely=0.63)
    
    # Profile name entry
    global profile_name_entry
    profile_name_entry = Entry(profile_manager_window, width=22, textvariable=profile_name_to_add)
    profile_name_entry.place(relx=0.28, rely=0.65)
    profile_name_to_add.set("custom_profile")
        
# Loads selected profile from manager  
def load_profile():
    
    profile = selected_profile.get()
    dir = profile_directory.get()
    file = dir + '\\' + profile
    
    f = open(file, 'r')
    
    # Append each line in text file to list
    params = []
    for i in f.readlines():
        i = i.replace('\n', '')
        params.append(i)
    
    # Check if list is correct length before changing profile
    if len(params) == 20:

        profile_error_label['text'] = ''
        # Close Current window and open new operation for profile
        on_closing()
        if params[0] == 'single device':
            
            if windowNum == 1:
                singleDevice_gui.destroy()
                open_SingleDevice()    
            else:    
                open_SingleDevice()
                
        elif params[0] == 'column':
            
            if windowNum == 2:
                columnBinary_gui.destroy()
                open_ColumnBinary()    
            else:    
                open_ColumnBinary()
                
        elif params[0] == 'vmm':
            
            if windowNum == 3:
                columnBinary_gui.destroy()
                open_VMM()    
            else:    
                open_VMM()
                
        elif params[0] == 'endurance':
            
            if windowNum == 4:
                singleDevice_gui.destroy()
                open_endurance()    
            else:    
                open_endurance()
        
        b2.set(params[1])
        b3.set(params[2])
        b4.set(params[3])
        b5.set(params[4])
        b6.set(params[5])
        b7.set(params[6])
        b8.set(params[7])
        b9.set(params[8])
        b10.set(params[9])
        b11.set(params[10])
        b12.set(params[11])
        b13.set(params[12])
        b14.set(params[13])
        b15.set(params[14])
        b16.set(params[15])
        b17.set(params[16])
        b18.set(params[17])
        b19.set(params[18])
        b20.set(params[19])

    else: 
        
        profile_error_label['text'] = 'File is not correct format'
        
# Toggles update/delete choice confirmation
def confirm_delete_or_update(choice):

    delete_profile_button['text'] = 'Yes'
    delete_profile_button['bg'] = 'green4'
    load_profile_button['text'] = 'No'
    load_profile_button['bg'] = 'indian red'
    load_profile_button['command'] = end_confirm
    update_profile_button['state'] = DISABLED
    add_profile_button['state'] = DISABLED
    profile_dirBox['state'] = DISABLED
    change_profile_dir['state'] = DISABLED
    profile_name_entry['state'] = DISABLED

    profile = selected_profile.get()

    # Remove menu options
    profile_menu['menu'].delete(0, END)
    profile_menu['menu'].add_command(label=profile, command=_setit(selected_profile, profile))
    selected_profile.set(profile)

    if choice == 'delete':

        profile_error_label['text'] = '* Are you sure you want to delete? *'
        delete_profile_button['command'] = delete_profile

    elif choice == 'update':

        profile_error_label['text'] = '* Are you sure you want to update? *'
        delete_profile_button['command'] = lambda:add_or_update_profile('update')

# Resets Disabled Options when confirmation is complete
def end_confirm():

    profile_error_label['text'] = ''
    delete_profile_button['text'] = 'Delete'
    delete_profile_button['bg'] = 'white'
    delete_profile_button['command'] = lambda:confirm_delete_or_update('delete')
    load_profile_button['text'] = 'Load'
    load_profile_button['bg'] = 'white'
    load_profile_button['command'] = load_profile
    update_profile_button['state'] = NORMAL
    add_profile_button['state'] = NORMAL
    profile_dirBox['state'] = NORMAL
    change_profile_dir['state'] = NORMAL
    profile_name_entry['state'] = NORMAL

    # Redisplay Profile List 
    dir = profile_directory.get()
    profile_list = get_profiles(dir)
            
    # Remove current list of profiles
    selected_profile.set('')
    profile_menu['menu'].delete(0, END)
    
    # Add new list of profiles from directory
    for profile in profile_list:
        profile_menu['menu'].add_command(label=profile, command=_setit(selected_profile, profile))
    
    selected_profile.set(profile_list[0])

# Deletes selected profile from manager 
def delete_profile():
    
    profile = selected_profile.get()
    dir = profile_directory.get()
    file = dir + '\\' + profile
    
    # remove file from directory and update menu
    if os.path.isfile(file):
        
        os.remove(file)

        profile_list = get_profiles(dir)
        
        # Remove current list of profiles
        selected_profile.set('')
        profile_menu['menu'].delete(0, END)
        
        # Add new list of profiles from directory
        for profile in profile_list:
            profile_menu['menu'].add_command(label=profile, command=_setit(selected_profile, profile))
        
        selected_profile.set(profile_list[0])
        
        profile_dirBox.delete(0, END)
        profile_dirBox.insert(0, dir)

        profile_error_label['text'] = ''
        
        end_confirm()

    else:
        # If it fails, inform the user.
        profile_error_label['text'] = "No file found with that directory/name"

# Adds new profile or updates current profile 
def add_or_update_profile(choice):
    
    dir = profile_directory.get()
    if choice == 'add':
        name = profile_name_to_add.get() + '.txt'
    elif choice == 'update':
        name = selected_profile.get()
    file = dir + '\\' + name

    profile_params = get_parameters()

    # Check if name is already used before adding
    if choice == 'add':
        list = get_profiles(dir)
        for p in list:
            if p == name:
                profile_params = 'error2'

    if profile_params == 'error':

        end_confirm()
        profile_error_label['text'] = '* No operation window open *'
        #selected_profile.set(name) 
        
    else:
        
        if profile_params == 'error2':

            profile_error_label['text'] = '* Profile name already exists *'   

        else:
            
            profile_error_label['text'] = ''
            
            profile = open(file, 'w')
            profile.writelines(profile_params)
        
            profile_list = get_profiles(dir)
                
            # Remove current list of profiles
            selected_profile.set('')
            profile_menu['menu'].delete(0, END)
            
            # Add new list of profiles from directory
            for profile in profile_list:
                profile_menu['menu'].add_command(label=profile, command=_setit(selected_profile, profile))
            
            selected_profile.set(name)
            
            profile_dirBox.delete(0, END)
            profile_dirBox.insert(0, dir)
        
            if choice == 'update':
                end_confirm()
         
# Allows user to change profile directory 
def choose_profile_directory():
    
    global profile_menu
    
    # Choose new directory
    prompter = promptlib.Files()
    directory = prompter.dir()
    
    if directory == '':
        directory = 'profiles'
    
    # Get profile list from directory chosen
    profile_list = get_profiles(directory)
    
    # Remove current list of profiles
    selected_profile.set('')
    profile_menu['menu'].delete(0, END)
    
    # Add new list of profiles from directory
    for profile in profile_list:
        profile_menu['menu'].add_command(label=profile, command=_setit(selected_profile, profile))
    
    selected_profile.set(profile_list[0])
    
    profile_dirBox.delete(0, END)
    profile_dirBox.insert(0, directory)
    
# Gets list of profiles from chosen profile directory
def get_profiles(dir):
    
    profiles = []
    
    for file in os.listdir(dir):
        
        if '.txt' in file:
            profiles.append(file)
        
    return profiles

# Gets paramaters from operation window to add to profile
def get_parameters():

    params = []
    
    if windowNum == 0:
        
        return 'error'
    
    else:
        
        # Add window type
        if windowNum == 1:
            params.append('single device\n')
        elif windowNum == 2:
            params.append('column\n')
        elif windowNum == 3:
            params.append('vmm\n')
        elif windowNum == 4:
            params.append('endurance\n')
            
        
        # Add byte values
        params.append(b2.get() + '\n')
        params.append(b3.get() + '\n')
        params.append(b4.get() + '\n')
        params.append(b5.get() + '\n')
        params.append(b6.get() + '\n')
        params.append(b7.get() + '\n')
        params.append(b8.get() + '\n')
        params.append(b9.get() + '\n')
        params.append(b10.get() + '\n')
        params.append(b11.get() + '\n')
        params.append(b12.get() + '\n')
        params.append(b13.get() + '\n')
        params.append(b14.get() + '\n')
        params.append(b15.get() + '\n')
        params.append(b16.get() + '\n')
        params.append(b17.get() + '\n')
        params.append(b18.get() + '\n')
        params.append(b19.get() + '\n')
        params.append(b20.get() + '\n')
    
    return params



'''
----------------------
File Exporting Window
----------------------
Functions which deal with exporting the data returned from the PCB board into a formatted CSV file
'''
# Arranges the raw data from the board so it can be exported in correct format for single device operation
def arrange_SD_export(data, byte6, byte14, cyc, row, col, v1, v2):
    
    # split data based on where the user reads
    if byte6 == 4 and byte14 == 4:

        list1, list2 = split_data(data)

    else:

        if byte6 == 4:

            list1 = data
            list2 = ['']
        
        if byte14 == 4:
             
            list1 = ['']
            list2 = data
    
    header = ['Cycle']
    header.append(b2.get())
    header.append(b10.get()) 
    
    # Create list of rows to add to csv
    data_list = []
    
    device_num = str(int(row)) + str(int(col))
    
    # Create header with parameters
    data_list.append(['Measured current/resistance through Resistive Memory device (ReRAM)'])
    data_list.append(['Voltage 1:  ' + str(v1)])
    data_list.append(['Voltage 2:  ' + str(v2)])
    data_list.append(['Max Cycles:  ' + str(int(cyc))])
    data_list.append([''])
    if unit == 'uA':
        data_list.append(['', 'Current (uA)'])
    elif unit == 'kOhm':
        data_list.append(['','Resistance (kOhm)'])
    data_list.append(['', '1st Read', '2nd Read']) # Add header row
    data_list.append(['Device', device_num, ''])
    data_list.append(header) # Add header row
    
    # Loop through all cycles
    for i in range(int(cyc)):
                
        # Declare row list
        row_to_add = []
        
        # Add cycle number
        row_to_add.append(str(i + 1))
        
        # Add 1st Read value
        if list1[0] == '':
            row_to_add.append('')
        else:
            row_to_add.append(str(list1[i]))

        # Add 2nd Read value
        if list2[0] == '':
            row_to_add.append('')
        else:
            row_to_add.append(str(list2[i]))
        
        data_list.append(row_to_add)
        
    return data_list

# Arranges the raw data from the board so it can be exported in correct format for endurance operation
def arrange_endurance_export(data, byte6, byte14, cyc, v1, v2):
    
    master_list1 = []
    master_list2 = []
    
    for i in range(len(data)): # Loop through each list of outputs for each device

        # Separate data into set/reset based on parameter selection
        if byte6 == 4 and byte14 == 4:
                
            list1, list2 = split_data(data[i])
            master_list1.append(list1)
            master_list2.append(list2)
        
        else:

            if byte6 == 4:

                list1 = data[i]
                list2 = ['']
                master_list1.append(list1)
                master_list2.append(list2)
            
            if byte14 == 4:
                
                list1 = ['']
                list2 = data
                master_list1.append(list1)
                master_list2.append(list2)
            
    
    # Create list of rows to add to csv    
    data_list = []
    
    data_list.append(['Endurance Test of entire array'])
    data_list.append(['Voltage 1:  ' + str(v1)])
    data_list.append(['Voltage 2:  ' + str(v2)])
    data_list.append(['Max Cycles:  ' + str(int(cyc))])
    data_list.append([''])
    if unit == 'uA':
        data_list.append(['', 'Current (uA)'])
    elif unit == 'kOhm':
        data_list.append(['','Resistance (kOhm)'])
    data_list.append(['', 'row,column'])
            
    for i in range(int(cyc + 2)): # Each cycle is a column
        
        cycle = i - 2
        index = 0
        row_to_add = []
        
        if i == 0:
            
            row_to_add.append('Device')
            
            for row in range(array_size): # loop through rows
                for col in range(array_size): # loop through columns
                    device_num = str(int(row + 1)) + ',' + str(int(col + 1))
                    row_to_add.append(device_num)
                    row_to_add.append('')
                    
        elif i == 1:
            
            row_to_add.append('Cycle')
            
            for row in range(array_size): # loop through rows
                for col in range(array_size): # loop through columns
            
                    row_to_add.append(b2.get())
                    row_to_add.append(b10.get())
        else:
            
            row_to_add.append(str(cycle + 1))
        
            for row in range(array_size): # loop through rows
                for col in range(array_size): # loop through columns
                        
                    # Add 1st Read value
                    if master_list1[index][0] == '':
                        row_to_add.append('')
                    else:
                        row_to_add.append(str(master_list1[index][cycle]))

                    # Add 2nd read value
                    if master_list2[index][0] == '':
                        row_to_add.append('')
                    else:
                        row_to_add.append(str(master_list2[index][cycle]))
                    
                    index += 1
                
        data_list.append(row_to_add)
                
    return data_list

# Arranges the raw data from the board so it can be exported in correct format for column programming operation
def arrange_column_export(data, col, device_states):
    
    data_list = []
    binary_seq = ''
    
    for state in device_states:
        binary_seq += str(int(state)) 
    
    data_list.append(['Column programming results'])
    data_list.append(['Column #', str(int(col))])
    
    # Allows excel to show all digits of binary number (ex. cell shows 00000010 instead of 10)
    temp_row = ['Binary #:', str(binary_seq)]
    temp_row = tuple("=\"" + r + "\"" for r in temp_row)
    data_list.append(temp_row)
    
    data_list.append([''])
    
    for i in range(len(data[-1]) + 2): # cycle through devices in column + 2 for headers
        
        device_num = i - 2
        row_to_add = []
        
        if i == 0:
            
            row_to_add.append('')
            row_to_add.append('Cycle #')
            
            for j in range(len(data)):
                
                row_to_add.append(j + 1)
        
        if i == 1: # create header row
            
            row_to_add.append('Device')
            row_to_add.append('Operation')
            
            for j in range(len(data)):
                
                if unit == 'uA':
                    row_to_add.append('Current (uA)')
                elif unit == 'kOhm':
                    row_to_add.append('Resistance (kOhm)')
                    
        elif i >= 2: # if not header
        
            row_to_add.append(device_num + 1)
            
            if device_states[device_num] == 1: # if value is from set
                row_to_add.append('Set')
                
            else: # if value is from reset 
                row_to_add.append('Reset')
                    
            for j in range(len(data)): # loop through all cycles
                row_to_add.append(data[j][device_num])
        
        data_list.append(row_to_add)
    
    return data_list
            
# Arranges the raw data from the board so it can be exported in correct format for VMM operation
def arrange_vmm_export(data, cyc, col):
    
    data_list = []
    
    data_list.append(['VMM results'])
    data_list.append(['Column #:  ' + str(int(col))])
    data_list.append([''])
    data_list.append(['Cycle','Current (uA)'])
   
    
    for i in range(int(cyc)):
        
        row_to_add = []
        
        # add cycle number
        row_to_add.append(i + 1)
        
        # add data point
        row_to_add.append(data[i])
    
        data_list.append(row_to_add)   
        
    return data_list

# Arranges the raw data from the board so it can be exported in correct format for binary VMM cycle operation
def arrange_vmm_cycle_export(data, cyc, col, binary_list):

    # Create list of rows to add to csv    
    data_list = []
    
    data_list.append(['VMM Operation performed through all possible combinations of binary numbers 0-256'])
    data_list.append(['Column #:  ' + str(int(col))])
    data_list.append(['Max Cycles:  ' + str(int(cyc))])
    data_list.append([''])
    if unit == 'uA':
        data_list.append(['', 'Current (uA)'])
    elif unit == 'kOhm':
        data_list.append(['', 'Resistance (kOhm)'])
    data_list.append(['', 'Integer/Binary'])

    for i in range(int(cyc + 2)): # Each cycle is a column
        
        cycle = i - 2
        row_to_add = []


        if i == 0:

            row_to_add.append('')

            for j in range(len(binary_list)): # create row of integer values

                    row_to_add.append(j)

        elif i == 1:
            
            row_to_add.append('Cycle')
            
            for j in range(len(binary_list)): # create row of binary values

                    row_to_add.append(str(binary_list[j]))
            
            row_to_add = tuple("=\"" + r + "\"" for r in row_to_add)
  
        else:
            
            row_to_add.append(str(cycle + 1))

            for j in range(len(binary_list)):

                row_to_add.append(data[j][cycle])

        data_list.append(row_to_add)

    return data_list

# Seperate board output data into set/reset results
def split_data(data):
    
    list1 = []
    list2 = []
        
    for i in range(len(data)):
        
        if i % 2 == 0:
            list1.append(data[i])
        else:
            list2.append(data[i])
                
    return list1, list2

# Initializes opening export settings window
def init_export_settings():
    
    global file_save_window
    
    try:
        
        if file_save_window.state() == 'normal':
            
            print('already open')
        
    except:
        
        open_file_save_window()

# Opens export settings window
def open_file_save_window():
    
    global file_save_window, file_name, save_directory, save_file_name_str, save_directory_str
    
    file_save_window = Toplevel(master)
    
    file_save_window.title("Export Settings")
    
    file_save_canvas = Canvas(file_save_window, width=450, height=130)
    file_save_canvas.grid(rowspan=20,columnspan=4) # separates window into N number of equally spaced columns/rows 
    
    file_save_window.resizable(False,False)
    #file_save_window.protocol("WM_DELETE_WINDOW", on_closing)
    
    file_name = StringVar()
    save_directory = StringVar()
    
    # Labels
    file_label1 = Label(file_save_window, text="Name of file:", font = ('calibre', 10, 'normal')).place(relx=0.05, rely=0.6)
    file_label2 = Label(file_save_window, text=".csv", font = ('calibre', 10, 'normal')).place(relx=0.65, rely=0.6)
    file_label3 = Label(file_save_window, text="Current Export Folder:", font = ('calibre', 12, 'bold')).place(relx=0.05, rely=0.06)
    
    # Message box
    global dirBox
    dirBox = Entry(file_save_window, width=45, textvariable=save_directory, font = ('calibre',10,'normal'), bg="white")
    dirBox.place(relx=0.245, rely=0.31)
    
    # File directory Button
    change_dir = Button(file_save_window, text="Change Dir", command=choose_export_directory, height=1, width=10, bg="white")
    change_dir.place(relx=0.05,rely=0.28)
    
    # Entry box for File name
    global file_name_entry
    file_name_entry = Entry(file_save_window, width=25, textvariable=file_name, font = ('calibre',10,'normal'), bg="white")
    file_name_entry.place(relx=0.25, rely=0.6)
    
    # File directory Button
    save_export = Button(file_save_window, text="Save", command=save_export_settings, height=2, width=6, bg="white")
    save_export.place(relx=0.86,rely=0.62)
    
    # Display current save settings
    file_name_entry.delete(0, END)
    file_name_entry.insert(0, save_file_name_str)
    dirBox.delete(0, END)
    dirBox.insert(0, save_directory_str)

# Allows user to change export directory folder
def choose_export_directory():
    
    prompter = promptlib.Files()
    directory = prompter.dir()
    
    if directory == '':
        directory = 'csv_files\\'

    dirBox.delete(0, END)
    dirBox.insert(0, directory)

# Saves export settings set in window until changed or reset app
def save_export_settings():
    
    global save_file_name_str, save_directory_str
    
    save_file_name_str = file_name.get()
    save_directory_str = save_directory.get()
    
    if save_directory_str == '':
        save_directory_str = 'csv_files'
        
# Toggles unit between uA and kOhm
def toggle_unit():

    global unit
    
    # Change output box display to correct unit
    if windowNum == 1 or windowNum == 4: # if in single device/endurance operation

        new_out_str = ''
        str_to_print = ''
        
        out_str = outputBox.cget('text')
        split_out_str = out_str.split(':\n')
        if len(split_out_str) > 1:
            if 'Resistance' in split_out_str[0]:
                str_to_print = 'Current (uA):\n'
            if 'Current' in split_out_str[0]:
                str_to_print = 'Resistance\nkOhm:\n'
            new_out_str = split_out_str[1].split('\n')
            
        if new_out_str != '' and len(v_read) == 2:
            
            v_read1 = v_read[0]
            v_read2 = v_read[1]
            
            del new_out_str[-1]

            convert_unit(new_out_str, v_read1, v_read2)
            
            for val in new_out_str:
                str_to_print += str(val) + '\n'
                
            outputBox['text'] = str_to_print
            
        else:
            
            outputBox['text'] = ''
            
    elif windowNum == 2 or windowNum == 3: # if in column programming/vmm operation
        
        if len(v_read) == 2: # make sure previous data obtained
            
            v_read1 = v_read[0]
            v_read2 = v_read[1]
            
            for i in range(array_size):
            
                col_num = int(i + 1)
                column_data = get_column_data(col_num)
                
                convert_unit(column_data[0], v_read1, v_read2)
                
                store_column_data(col_num, column_data[0], column_data[1])
                
                if int(b19.get()) == col_num and out1.cget('text') != '': # selected column outputs get displayed
                    print_to_columns(column_data)
                     
    # Change labels
    if unit == 'uA':
        
        # Labels
        unit = 'kOhm'
        unit_button['text'] = 'kOhm'
        if windowNum == 1 or windowNum == 4:
            rangeLabel4['text'] = 'Desired Range (kOhm)'
        elif windowNum == 2 or windowNum == 3:
            #total_label2['text'] = 'kOhm'
            col_label_unit['text'] = 'Output (kOhm)'
            
    elif unit == 'kOhm':
        
        unit = 'uA'
        unit_button['text'] = 'uA'
        if windowNum == 1 or windowNum == 4:
            rangeLabel4['text'] = 'Desired Range (uA)'
        elif windowNum == 2 or windowNum == 3:
            #total_label2['text'] = 'uA'
            col_label_unit['text'] = 'Output (uA)'
            
# Converts list of current outputs to resistance values
def convert_unit(board_output, v_read1, v_read2):
    
    for i in range(len(board_output)):
        
        if board_output[i] != 0:
            
            if i % 2 == 0: # first read voltage
                val = abs(float(v_read1)/float(board_output[i])) * 1000 # calc R
                board_output[i] = round(val, 2)
                
            elif i % 2 == 1: # second read voltage
                val = abs(float(v_read2)/float(board_output[i])) * 1000 # calc R
                board_output[i] = round(val, 2)



'''
--------------
Master Window
--------------
'''
# Occurs when user closes master window
def close_master():
    master.destroy()
    quit()

# Occurs when user closes one of the operation windows (single device, endurance, column opertation, VMM)
def on_closing():
    
    global windowNum

    if windowNum == 1 or windowNum == 4: # if single device or endurance open -> close it
        singleDevice_gui.destroy()
    elif windowNum == 2 or windowNum == 3: # if column or vmm open -> close it
        columnBinary_gui.destroy()
        
    # Reset all buttons so they can be accessed
    SD_button["state"] = NORMAL
    col_button["state"] = NORMAL
    vmm_button["state"] = NORMAL
    endurance_button["state"] = NORMAL
    
    SD_button["relief"] = RAISED
    col_button["relief"] = RAISED
    vmm_button["relief"] = RAISED
    endurance_button["relief"] = RAISED
    
    # Reset window number as if just started program
    windowNum = 0


# Create and set up Master window
master = Tk() 
master_canvas = Canvas(master, width=280, height=630)
master_canvas.grid(rowspan=5,columnspan=1) 
master.resizable(False,False)
master.protocol("WM_DELETE_WINDOW", close_master)
master.title("ReRam Op Testing")

# Title Labels
titleLabel = Label(master, text="ReRam Testing", font = ('calibre',20, 'bold'))
titleLabel.place(relx=0.1, rely=0.05)

subLabel = Label(master, text="Operation Selection:", font = ('calibre',14,'normal'))
subLabel.place(relx=0.15, rely=0.15)

# Single device button
SD_button = Button(master, text="Single Device", command=open_SingleDevice, relief=RAISED, width=20, height=2, bg="gray", font = ('calibre',14, 'normal'))
SD_button.place(relx=0.1,rely=0.27)

# Endurance Button
endurance_button = Button(master, text="Endurance", command=open_endurance, relief=RAISED, width=20, height=2, bg="gray", font = ('calibre',14, 'normal'))
endurance_button.place(relx=0.1,rely=0.42)

# Column programming button
col_button = Button(master, text="Column Programming", command=open_ColumnBinary, relief=RAISED, width=20, height=2, bg="gray", font = ('calibre',14, 'normal'))
col_button.place(relx=0.1,rely=0.65)

# VMM button
vmm_button = Button(master, text="VMM Operation", command=open_VMM, relief=RAISED, width=20, height=2, bg="gray", font = ('calibre',14, 'normal'))
vmm_button.place(relx=0.1,rely=0.8)

# VMM button
new_vmm_button = Button(master, text=" NEW VMM Operation", command=open_NEW_VMM, relief=RAISED, width=20, height=2, bg="gray", font = ('calibre',14, 'normal'))
new_vmm_button.place(relx=0.1,rely=0.9)

# Menu
menubar = Menu(master)
file_menu = Menu(menubar, tearoff=0)
file_menu.add_command(label='Export', command=init_export_settings)
file_menu.add_command(label='Profiles', command=init_profile_manager)
file_menu.add_separator()
file_menu.add_command(label="Exit", command=on_closing)
menubar.add_cascade(label="File", menu=file_menu)
master.config(menu=menubar)


# Main loop for Master GUI
master.mainloop()
